---

title: Injecting logic in the middle of an algorithm using “Func<T>” function parameters
date: '2010-02-28T14:14:00.001+01:00'
orgauthor: Joost van Schaik
tags:
- refactoring
- Lambda expressions
- dotnetmag
- C#
- Architecture
- delegates
- Functional programming
modified_time: '2010-09-30T08:34:01.979+02:00'
blogger_id: tag:blogger.com,1999:blog-5295746446529817470.post-8538018449022545184
blogger_orig_url: https://dotnetbyexample.blogspot.com/2010/02/injection-logic-in-middle-of-algorithm.html
---

<p>Sometimes you run into a situation in which you have a very similar complex pieces of logic, that only differ somewhere deep inside. This happens especially when you are dealing with legacy code that requires all kinds of weird initializers. Consider the following example, which is similar to something I ran into deep down in a CSLA library: </p> <pre>private void DataPortal_Fetch(string a, string b, string c)
{
  var helper = new LoaderHelper();
  helper.Init();
  LegacyObjectCollection result = <br />    OldStaticHelper.GetByThreeStrings( a, b, c);
  IsReadOnly = false;
  result.ForEach(p =&gt; Add(SomeNewObject.Get(p, helper)));
  RaiseListChangedEvents = false;
  IsReadOnly = true;
}

private void DataPortal_Fetch(string a, int n)
{
  var helper = new LoaderHelper();
  helper.Init();
  LegacyObjectCollection result = OldStaticHelper.GetByOtherKeys( a, n);
  IsReadOnly = false;
  result.ForEach(p =&gt; Add(SomeNewObject.Get(p, helper)));
  RaiseListChangedEvents = false;
  IsReadOnly = true;
}</pre>
<p>The idea clearly was to call some legacy code and transform this into a list of “SomeNewObject”. But the annoying thing about the legacy code was that all kinds of helpers needed to be initialized before OldStaticHelper could be called. And then the logic of transforming the data had been duplicated as well. There are a number of ways to refactor this, but because I was fooling around with functional programming concepts at the time, I tried the following, which almost worked: </p>
<pre>private void DataPortal_Fetch(string a, string b, string c)
{
  FetchData(OldStaticHelper.GetByThreeStrings( a, b, c)); 
}

private void DataPortal_Fetch(string a, int n)
{
  FetchData(OldStaticHelper.GetByOtherKeys( a, n));
}

private void FetchData(Func&lt;LegacyObjectCollection&gt; loaderMethod)
{
  var helper = new LoaderHelper();
  helper.Init();
  LegacyObjectCollection result = loaderMethod();
  IsReadOnly = false;
  result.ForEach(p =&gt; Add(SomeNewObject.Get(p, helper)));
  RaiseListChangedEvents = false;
  IsReadOnly = true;
}</pre>
<p>Although this compiled an ran, it did not work as expected. Upon calling “FetchData” the OldStaticHelper.GetBy… method was instantly executed, in stead of of when “result = loaderMethod()” was called. And I just stated that it would not work unless the “helper” code was initialized. Thus, I needed to use delegates: </p>
<pre>private void DataPortal_Fetch(string a, string b, string c)
{
  FetchData(() =&gt; OldStaticHelper.GetByThreeStrings( a, b, c)); 
}

private void DataPortal_Fetch(string a, int n)
{
  FetchData(() =&gt; OldStaticHelper.GetByOtherKeys( a, n));
}</pre>
Or, for those not familiar with the lambda syntax: 

<pre>private void DataPortal_Fetch(string a, string b, string c)
{
  FetchData(delegate { return OldStaticHelper.GetByThreeStrings( a, b, c)}); 
}

private void DataPortal_Fetch(string a, int n)
{
  FetchData(delegate { return OldStaticHelper.GetByOtherKeys( a, n)});
}</pre>
Using this technique you can 'inject' a piece of logic into a larger algorithm, eliminating the need to duplicate code or making all kinds of in-between data sets 

  