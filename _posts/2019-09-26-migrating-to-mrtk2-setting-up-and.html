---
layout: post
title: Migrating to MRTK2 - setting up and understanding Eye Tracking
date: '2019-09-26T20:33:00.000+02:00'
author: Joost van Schaik
tags:
- Unity
- Windows Mixed Reality
- MRTK2
- HoloLens2
modified_time: '2019-09-27T06:44:19.850+02:00'
thumbnail: https://i.ytimg.com/vi/Ych87QTV3EA/default.jpg
blogger_id: tag:blogger.com,1999:blog-5295746446529817470.post-8302476992650493302
blogger_orig_url: https://dotnetbyexample.blogspot.com/2019/09/migrating-to-mrtk2-setting-up-and.html
---

<h2>Intro</h2><p>One of the exiting features <a href="https://www.microsoft.com/en-us/hololens" target="_blank">HoloLens</a> 2 brings us, is Eye Tracking. On HoloLens 1, you had to move your whole head to move the gaze cursor. and while that works well enough for a lot of applications and it seems most people pretty quickly got used to it, mother Nature has equipped us with roving eyes. HoloLens 2, when calibrated for Eye Tracking, can actually track what your are <em>looking</em> at, not merely where your head is pointed at. </p><p>Although there is a nice demo in the <a href="https://www.microsoft.com/en-us/windows/windows-mixed-reality" target="_blank"><a href="https://github.com/Microsoft/MixedRealityToolkit-Unity" target="_blank">Mixed Reality Toolkit</a> 2, it took me a while to find out how all the events actually work and need to be hooked up to get it to work consistently. So I made a little demo that works like this:</p><iframe width="650" height="365" src="https://www.youtube.com/embed/Ych87QTV3EA" frameborder="0" allowfullscreen="" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe><h2>Events and tracking them</h2><p>The little blue globe is the target, is equipped with and EyeTrackingTarget script from the MRTK2 that supports five events, which you can see going off as the red spheres turns green</p><ul><li>LS: On Look At Start</li><li>WL: While Looking At Target</li><li>LA: On Look Away</li><li>DW: On Dwell</li><li>S: On Selected</li></ul><p>The EyeTrackingTarget is configured as follows:</p><p><img width="273" height="400" style="border: 0px currentcolor; border-image: none; background-image: none;" src="https://schaikweb.net/blog/20190925/EyeTracking.png" border="0"></p><p><img align="left" style="margin: 0px 9px 0px 0px; border: 0px currentcolor; border-image: none; float: left; display: inline; background-image: none;" src="https://schaikweb.net/blog/20190925/EyeTrackerScene.png" border="0">In the scene, the whole thing showing the images (the five little red-turning-green globes with labels) is one prefab containing 5 little spheres with a label above it - each a prefab on its own. Every sphere has a "Single Shot Controller" script that turns it's sphere green for 0.5 seconds when an event is called.</p><p><img width="235" height="100" style="border: 0px currentcolor; border-image: none; display: inline; background-image: none;" src="https://schaikweb.net/blog/20190925/SingleShotController.png" border="0"></p><p>It's a super simple script, the interesting part is even shorter:</p><pre>public void ShowActivated()
{
    _timeActivated = Time.time;
}

void Update()
{
    var desiredColor = Time.time - _timeActivated &gt; _resetTime ? 
        _originalColor : _activatedColor;
    if (_material.color != desiredColor)
    {
        _material.color = desiredColor;
    }
}</pre><p>When ShowActivated is called, the _timeActivated field is set to now. The Update loop then checks every 60th of a second whether it should set the color to red or green, depending on the fact if the latest call to ShowActivated is already half a second ago.</p><h2>What happens when</h2><p>The event names are pretty straightforward, and things happen more or less than you expect, although </p><p>What is actually happening:</p><ul><li>When the user first looks at the eye tracked object, "On Look Start" is fired once</li><li><em>While</em> the user keeps looking, "While Looking At Target" <em>keeps being called. </em>Thus, the green sphere stays green. The calling seems to at the same instant - or nearly the same instant - as the previous event</li><li>As soon as the user stops looking at the sphere, "On Look Away" is called and "While Looking At Target" is stopped being called</li><li>"On Dwell" is being called after the time defined in the "Dwell Time in Sec" slider has passed has the user is <em>still</em> looking at the object. I took the ridiculously user-unfriendly time of three seconds to make sure this event was easily distinguishable from the other events. Here's the thing though - it's being called <em>once</em>. That kind of confused me.</li><li>"On Selected" is being called when then object being looked at <em>and</em> you say "Select". This is one of the predefined commands in the default speech commands profile (DefaultMixedRealitySpeechCommandsProfile)</li></ul><h2>Setting up and configuring eye tracking in profiles</h2><p>Coming from the default profile, you will need to configure at least profiles, and better still three.</p><p>First, you will need to clone the Default Toolkit profile itself. First thing I do, while still in the early phases, is disabling the diagnostics system as I don't want that profiler in my face the whole time:</p><p><img width="366" height="100" style="border: 0px currentcolor; border-image: none; background-image: none;" src="https://www.schaikweb.net/blog/20190925/diagnostics.png" border="0"></p><p>Next, you will have to clone the Input System Profile and add a Windows Mixed Reality Eye Gaze Provider" </p><p><img width="500" height="565" style="border: 0px currentcolor; border-image: none; background-image: none;" src="https://schaikweb.net/blog/20190925/ConfigureEyeGazer.png" border="0"></p><p>As you can see, this sits in namespace "Microsoft.MixedReality.Toolkit.WindowsMixedReality.Input"</p><p>And then finally, and optionally, if you want this to work in the editor too, you will have to configure the Input Simulation Service. You do that by cloning the default input system profile and check the "Simulate Eye Position" checkbox </p><p><img width="301" height="500" style="border: 0px currentcolor; border-image: none; background-image: none;" src="https://www.schaikweb.net/blog/20190925/SimulateEyePos.png" border="0"></p><h2>One more thing: setting capabilities</h2><p><img width="288" height="300" align="left" style="margin: 0px 9px 0px 0px; border: 0px currentcolor; border-image: none; float: left; display: inline; background-image: none;" src="https://www.schaikweb.net/blog/20190925/capabilities.png" border="0">You will notice now the Gaze cursor turning up in the editor so you might thing you are done. Well, almost. There's the small matter of capabilities. C++ or not, the result is still a UWP app, and Gaze Input is a capability that you need to ask consent for. This, unfortunately, is not yet implemented in Unity. So after you generated the C++ app, you will need to open it in Visual Studio, select the Package.appmanifest file, and select <em>there</em> the Gaze Input capability.<br><br></p><p>&nbsp;<img width="203" height="127" align="left" style="margin: 0px 9px 0px 0px; border: 0px currentcolor; border-image: none; float: left; display: inline; background-image: none;" src="https://www.schaikweb.net/blog/20190925/consent.png" border="0">If you deploy the resulting solution to an emulator (or, if you are one of the lucky ones out there, an actual HoloLens 2) and it asks for your consent, you did it right.</p><h2>Conclusion and final words</h2><p>Setting up Eye Tracking is not that hard, but it takes a few steps. Mind you the MRTK2 comes with a few profiles that make settings things up easier - I just wrote down the steps from scratch. <a href="https://github.com/LocalJoost/EyeTrackingDemo" target="_blank">The demo project</a> shows this in all it's glory ;) and allows you to play with it yourself without having to set it up. Notice there's hardly any code outside of the MRKT2 itself involved - there's only one custom script (my SingleShotController) and that's very simple.</p><p>By the way - in my own (so far single) HoloLens 2 app I only use the On While Looking event. This seems to be the most trustworthy. I previous iterations of the MRTK2 and/or the HoloLens emulator the other events did not go off reliably enough (IMHO) to use them for real. Of course, this may all be different now, and most likely is completely different (better) on a real device. We are still waiting for that. </p><p>On a final note – leaving the eye cursor visible can be confusing and/or annoying, or so I have been told. So under normal circumstances, it should be turned off – the object being looked should give some indication it is notices being looked at. I have found a way to do this myself, but that’s pretty complex, and just as I was about to blog about that, <a href="https://twitter.com/julenka" target="_blank">Julia Schwarz</a> herself added <a href="https://github.com/microsoft/MixedRealityToolkit-Unity/blob/mrtk_development/Assets/MixedRealityToolkit.Examples/Demos/Input/Scenes/DisablePointers/DisablePointersExample.cs" target="_blank">a (better) sample to turn off pointers by code</a> to the main MRTK2 repo.</p>