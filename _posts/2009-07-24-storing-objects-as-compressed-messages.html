---
layout: post
title: Storing objects as compressed messages in the Windows Azure Queue
date: '2009-07-24T19:03:00.018+02:00'
author: Joost van Schaik
tags:
- Message Queue
- Azure
- dotnetmag
- GZip
- Compress
- Serialization
- XML
- Extension methods
modified_time: '2010-04-06T11:17:29.879+02:00'
blogger_id: tag:blogger.com,1999:blog-5295746446529817470.post-2628106726452178999
blogger_orig_url: https://dotnetbyexample.blogspot.com/2009/07/storing-objects-as-compressed-messages.html
---

For my current private R&D project I wanted to store 'task set' objects (in code samples below as shown type "Request") on the Windows Azure Queue. To prevent serialization issues I opted for XML serialization, like this:<pre>private void Enqueue(Request tr)
{
  var queueStorage = QueueStorage.Create(
  StorageAccountInfo.GetDefaultQueueStorageAccountFromConfiguration());
  var queue = queueStorage.GetQueue("MyQueue");
  if (!queue.DoesQueueExist())
  {
    queue.CreateQueue();
  }

  var xmlSerializer = new XmlSerializer(tr.GetType());
  using (var stringWriter = new StringWriter())
  {
    xmlSerializer.Serialize(stringWriter, tr);
    queue.PutMessage(new Message(stringWriter.ToString()));
  }
}</pre>I would let the worker role deserialize the Request object and then execute it. It annoyed me to no end to learn that the Azure Queue limits message sizes to 8192 bytes. 

I could have redesigned my task sets to smaller units, but that would hurt the efficiency of the process I had in mind. 

Based upon the <a href="http://localjoost.github.io/2009/08/15/serializing-objects-to-compressed-xml.html">StringZipExtensions class I blogged about</a> that can serialize and deserialize any old object to and from compressed XML (which you can download <a href="http://schaikweb.net/dotnetbyexample/StringZipExtensions.zip">here</a>) I created the following extension methods, which enable you to store objects as a GZip compressed set of bytes on the Azure queue and retrieve them again:<pre>using LocalJoost.Utilities.Compression;
using Microsoft.Samples.ServiceHosting.StorageClient;

namespace LocalJoost.Utilities.Azure
{
  public static class MessageQueueExtensions
  {
    /// &lt;summary&gt;
    /// Decompresses the specified queue message.
    /// &lt;/summary&gt;
    /// &lt;param name="message"&gt;The message.&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public static string Decompress(this Message message)
    {
      return message != null ?
       message.ContentAsBytes().DecompressToString() : null;
    }

    /// &lt;summary&gt;
    /// Decompresses the specified queue message.
    /// to an object
    /// &lt;/summary&gt;
    /// &lt;param name="message"&gt;The message.&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public static T Decompress &lt;T&gt;(this Message message) where T:class
    {
      return message != null ?
       message.ContentAsBytes().DecompressToObject&lt;T&gt;() : null;
    }
  }
}
</pre>Adhering to my first code sample, you can now simply put an object to the queue like this<pre>private void Enqueue(Request tr)
{
  var queueStorage = QueueStorage.Create(
    StorageAccountInfo.GetDefaultQueueStorageAccountFromConfiguration());
  var queue = queueStorage.GetQueue("MyQueue");
  if (!queue.DoesQueueExist())
  {
    queue.CreateQueue();
  }

  queue.<span color="red">PutCompressedObject</span>(tr);
}</pre>and let the worker role use the Decompress extension method on the Message itself:<pre>var queueStorage =
  QueueStorage.Create(
  StorageAccountInfo.GetDefaultQueueStorageAccountFromConfiguration());
var queue = queueStorage.GetQueue("MyQueue");
if (queue.DoesQueueExist())
{
  var message = queue.GetMessage(600);
  if (message != null)
  {
    var request = message.Decompress&lt;Request&gt;();
    request.Execute();
    queue.DeleteMessage(message);
  }
}</pre>And there you go. It is as simple as that. Although the Window Azure Queue message queue size still is limited to 8192, the amount of data that fits in that space is increased dramatically.