---

title: Extension methods to animate an object over the screen via waypoints for Windows
  Phone
date: '2013-07-22T20:26:00.001+02:00'
orgauthor: Joost van Schaik
tags:
- wpnl
- wpdev
- dotnetmag
- WP7NL
- Windows Phone
modified_time: '2013-08-17T20:40:35.706+02:00'
blogger_id: tag:blogger.com,1999:blog-5295746446529817470.post-5704302111700798982
blogger_orig_url: https://dotnetbyexample.blogspot.com/2013/07/extension-methods-to-animate-object.html
---

<p>A long time ago, before I even was a Microsoft MVP, <a href="http://dotnetbyexample.blogspot.nl/2011/03/simple-windows-phone-7-silverlight.html" target="_blank">I wrote an article about a behavior that could make anything draggable and flickable</a> for <a href="http://www.microsoft.com/windowsphone/?ocid=aff-n-we-loc--ITPRO40939&amp;WT.mc_id=aff-n-we-loc--ITPRO40939" target="_blank">Windows Phone</a> (then still 7). That article used a few extension methods to <a href="http://msdn.microsoft.com/en-us/library/system.windows.frameworkelement.aspx" target="_blank">FrameworkElement</a> and <a href="http://msdn.microsoft.com/en-us/library/system.windows.media.animation.storyboard(v=VS.95).aspx" target="_blank">Storyboard</a> to create the desired effect Those extension methods are a bit limited, because they can only create an animation that move an object from one location to another – there are no possible points in between.</p> <p>The Windows Phone 8 game I am currently developing needs just that, and as usual, as soon as I created something reusable, I spin it off to my library and start blogging about it. Don’t despair if you don’t get the whole explanation – I explain how I created the code and what it does, but if you don’t care, you can just copy it and use the resulting calls.</p> <p>The earlier extension methods created a <a href="http://msdn.microsoft.com/en-us/library/system.windows.media.animation.doubleanimation.aspx" target="_blank">DoubleAnimation</a>. Well actually it created two – one to animate the TranslateX property of a <a href="http://msdn.microsoft.com/en-us/library/system.windows.media.compositetransform(v=VS.95).aspx" target="_blank">CompositeTransform</a>, the other to animate the TranslateY property, over a certain <a href="http://msdn.microsoft.com/en-us/library/system.windows.duration.aspx" target="_blank">Duration</a>. But these kinds of ‘simple’ animations are executed in parallel in a Storyboard – and now I want to do <em>consecutive</em> animations. You then need key frames. And since the Translate properties are doubles, you need to create instances of <a href="http://msdn.microsoft.com/en-us/library/system.windows.media.animation.doubleanimationusingkeyframes.aspx" target="_blank">DoubleAnimationUsingKeyFrames</a> :). Luckily, the Microsoft developers creating this API did choose some logical names. There are a few things you should remember:</p> <ul> <li>The DoubleAnimationUsingKeyFrames animates the property, so <em>this</em> needs to be used in the SetTarget of the Storyboard  <li>For the individual animation frames you need to add <a href="http://msdn.microsoft.com/en-us/library/system.windows.media.animation.lineardoublekeyframe.aspx" target="_blank">LinearDoubleKeyFrame</a> instances to the DoubleAnimationUsingKeyFrames’ KeyFrames collection – with a key time and a value. This is the value which the animated property needs to have at the key time.  <li>The duration of the entire DoubleAnimationUsingKeyFrames needs to be equal to the sum of key times of the individual LinearDoubleKeyFrame key times.  <li>We need to animate both X and Y, so there needs to be two animations per key time, namely one for X and one for Y</li></ul> <p>Let’s do that!</p><pre>using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows;
using System.Windows.Media;
using System.Windows.Media.Animation;

namespace Wp7nl.Utilities
{
  public static class StoryboardExtensions2
  {
    public static Timeline CreateKeyFrameAnimation(this Storyboard storyboard, 
        IList&lt;double&gt; values, IList&lt;Duration&gt;times)
    {
      var keyFrameAnimation = new DoubleAnimationUsingKeyFrames();
      var keyTime = TimeSpan.FromMilliseconds(0);
      for (var i = 0 ; i&lt; values.Count(); i++)
      {
        keyTime += times[i].TimeSpan;
        var frame = new LinearDoubleKeyFrame {Value = values[i], KeyTime = keyTime};
        keyFrameAnimation.KeyFrames.Add(frame);
        keyFrameAnimation.Duration += times[i];
      }
      return keyFrameAnimation;
    }
  }
}</pre>
<p>This code is still pretty abstract, but it’s doing exactly what I described – it makes the DoubleAnimationUsingKeyFrames, adds the keyframes (of type LinearDoubleKeyFrame&nbsp; - I found that out using Blend and basically translated the XAML to C#) and makes the total duration equal to the sum of the durations.The first key frame on key time 0 is the first point – and from then we add more points and new key times.</p>
<p>This, of course, is not very “programmer friendly”. That is where the main extension method comes in:</p><pre>public static void AddWayPointAnimation(
  this Storyboard storyboard, FrameworkElement fe, 
  IList&lt;Point&gt; points, double speed)
{
  var durations = new List&lt;Duration&gt; {new Duration(TimeSpan.FromSeconds(0))};
  for (var i = 0; i &lt; points.Count - 1; i++)
  {
    durations.Add(points[i].<font color="#ff0000"><u>CalculateDuration</u></font>(points[i + 1], speed));
  }
  var xValues = points.Select(p =&gt; p.X).ToList();
  storyboard.<u><font color="#ff0000">AddAnimation</font></u>(fe.RenderTransform, 
    storyboard.CreateKeyFrameAnimation(xValues, durations), 
       CompositeTransform.TranslateXProperty);
  var yValues = points.Select(p =&gt; p.Y).ToList();
  storyboard.AddAnimation(fe.RenderTransform, 
    storyboard.CreateKeyFrameAnimation(yValues, durations), 
      CompositeTransform.TranslateYProperty);
}</pre>
<p>So you pass in an empty Storyboard, the GUI element you want to animate, a list of waypoints, and a speed (in pixels per second). And done. You can now simply use the following code:</p><pre>myGuiElement.RenderTransform = new CompositeTransform();
myGuiElement.RenderTransformOrigin = new Point(0.5, 0.5);
var s = new Storyboard();
s.AddWayPointAnimation(myGuiElement, myListOfPoint, 500);
s.Begin();</pre>
<p>And whatever is in myGuiElement will be animated over the waypoints. The first two statements can also be replaced by creating the transform in Blend. You may, by the way, have noticed some odd statements in AddWayPointAnimation. Both the red underlined statements are not part of the standard API. <a href="http://dotnetbyexample.blogspot.nl/2011/07/speed-and-distance-calculation.html" target="_blank">CalculateDuration is part of a few extension methods for Point that I wrote some time ago</a>, and <a href="http://dotnetbyexample.blogspot.nl/2011/03/simple-windows-phone-7-silverlight.html" target="_blank">AddAnimation is part of the original article I mentioned before</a>. Both are now part of my #<a href="http://wp7nl.codeplex.com/" target="_blank">wp7nl library on codeplex</a> (and its accompanying NuGet package) so I won’t go into details about this.</p>
<p><a href="http://www.schaikweb.net/dotnetbyexample/86e6ef6b072d_F27C/screenshot4.png"><img title="screenshot4" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; float: right; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="screenshot4" align="right" src="http://www.schaikweb.net/dotnetbyexample/86e6ef6b072d_F27C/screenshot4_thumb.png" width="148" height="244"></a>To demonstrate this principle I have made the following pinnacle of animation design:</p>
<p>When you hit the button “move”it will move the whole TitlePanel first a bit to the left, then down, then to the right, and finally up to where it came from. Pretty pointless to do this from code, but it proves the point.</p>
<p>Note that what we animate here is a <em>Translation</em>. So the coordinates used are relative coordinates within the container!</p>
<p>As usual, the full demo solution <a href="http://www.schaikweb.net/dotnetbyexample/DemoWayPoints.zip" target="_blank">can be downloaded here</a></p>  