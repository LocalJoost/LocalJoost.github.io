---
layout: post
title: Behaviors for animated scroll-down and slide-in menus in Xamarin Forms
date: '2016-04-13T13:55:00.000+02:00'
orgauthor: Joost van Schaik
tags:
- UWP
- Xamarin Forms
- XAML
- behavior
modified_time: '2016-04-13T15:30:20.553+02:00'
thumbnail: https://i.ytimg.com/vi/DNC2xoH2PB0/default.jpg
blogger_id: tag:blogger.com,1999:blog-5295746446529817470.post-7485121060706259678
blogger_orig_url: https://dotnetbyexample.blogspot.com/2016/04/behaviors-for-animated-scroll-down-and.html
comment_issue_id: 244
---

<h2>Preface</h2> <p>Some time ago I wrote about <a href="http://localjoost.github.io/view-model-driven-animations-using" target="_blank">a proof-of-concept for viewmodel driven animations using behaviors in Xamarin Forms</a>. In the mean time, time has moved on, so has Xamarin Forms, and the idea I had back then made it into a kind of framework solution I now used professionally. And it’s time to show how it’s done now in detail.</p> <p>This article is about building animated scroll-into-view menu’s in Xamarin Forms, and to make sure we all understand what that means, I made this little video showing the code in action on an Android emulator, a Windows 10 <a href="https://www.visualstudio.com/en-us/features/universal-windows-platform-vs.aspx">Universal Windows Platform</a> app, and an iPhone simulator:</p><iframe height="487" src="https://www.youtube.com/embed/DNC2xoH2PB0" frameborder="0" width="650" allowfullscreen></iframe> <h2>Framework</h2> <p>The <a href="https://github.com/LocalJoost/XamarinFormsDemos/tree/blog1" target="_blank">demo app</a> contains a simple framework (project DemoViewFramework) that supports a number of things crucial to an app sporting viewmodel driven behaviors, that is:</p> <ul> <li>facilitation of&nbsp; MVVM (using MVVMLight)  <li>registration of which view belongs to what viewmodel  <li>navigation from viewmode to viewmodel (in stead of from page to page)  <li>exposing essential events in the life cycle of the <em>page</em> to it’s accompanying <em>viewmodel</em>.</li></ul> <p>I won’t go into very much detail about the framework – it’s a pretty naïve implementation anyway – but there are two key things to take away. The first one is the class BaseContentPage </p><pre>using Xamarin.Forms;

namespace DemoViewFramework
{
  public class BaseContentPage : ContentPage
  {
    protected override void OnAppearing()
    {
      base.OnAppearing();
      Context?.OnViewAppearing();
    }

    protected override void OnSizeAllocated(double width, double height)
    {
      base.OnSizeAllocated(width, height);
      Context?.OnViewInitialized(true);
    }

    protected override void OnDisappearing()
    {
      base.OnDisappearing();
      Context?.OnViewInitialized(false);
      Context?.OnViewDisappearing();
    }

    private IPageViewModelBase Context =&gt; (IPageViewModelBase)BindingContext;
  }
}
</pre>This class is intended to be a base class for your pages, and it's sole purpose is to channel the OnAppearing, OnSizeAllocated and OnViewDisappearing events to the object in the Page's BindingContext - that is, the view model. To this intent, every view model should implement the interface IPageViewModelBase so the corresponding methods can be called: <pre>namespace DemoViewFramework
{
  public interface IPageViewModelBase
  {
    void OnViewInitialized(bool value);

    void OnViewAppearing(object state = null );

    void OnViewDisappearing();

    INavigationService NavigationService { get; set; }
  }
}</pre>If you are using your own Navigation framework, you can forget about the NavigationService property. To make implementation easier, there's a base class for view models – which is the second key takeaway. In the demo project is a child class from MVVMLight's ViewModelBase, but of course you are very free to implement your own INotifyPropertyChanged base class as well. <pre>using GalaSoft.MvvmLight;

namespace DemoViewFramework
{
  public class PageViewModelBase : ViewModelBase, IPageViewModelBase
  {
    public virtual void OnViewInitialized(bool value)
    {
      ViewIsInitialized = value;
    }

    private bool _viewIsInitialized;
    public bool ViewIsInitialized
    {
      get { return _viewIsInitialized; }
      set { Set(() =&gt; ViewIsInitialized, ref _viewIsInitialized, value); }
    }

    public virtual void OnViewAppearing(object state = null)
    {
      ViewHasAppeared = true;
    }

    public virtual void OnViewDisappearing()
    {
      ViewHasAppeared = false;
    }

    private bool _viewHasAppeared;
    public bool ViewHasAppeared
    {
      get { return _viewHasAppeared; }
      set { Set(() =&gt; ViewHasAppeared, ref _viewHasAppeared, value); }
    }

    public INavigationService NavigationService { get; set; }
  }
}</pre>Key thing here is that there are two properties - ViewHasAppeared and ViewIsInitialized - available in every view model and they are set automatically by the framework. Behaviors handling animations need to know when they actually can start doing stuff and they can <em>bind</em> to one of these properties. As I explained in a <a href="http://localjoost.github.io/xamarin-form-21-upgradesome-surprises" target="_blank">previous blog post</a>, from Xamarin 2.1 apparently you can only start after OnSizeAllocated, which translates to ViewIsInitialized in the view model, so the initialization code needs to be fired when that property is set to true. The actual activation of the behavior (that is, the animation), needs to come from <em>another</em> property. That may sound complicated, but I assure you it's not that bad. Just read on.
<h2>The (base) view model for driving animations</h2>
<p>Basically, we need something to kick off the animations. To this extent, we are using this very simple view model</p><pre>using DemoViewFramework;
using Xamarin.Forms;

namespace XamarinFormsDemos.ViewModels
{
  public class MenuViewModelBase : PageViewModelBase
  {
    private bool _isMenuVisible;

    public MenuViewModelBase()
    {
      ToggleMenuCommand = new Command(() =&gt; IsMenuVisible = !IsMenuVisible);
    }

    public bool IsMenuVisible
    {
      get { return _isMenuVisible; }
      set { Set(() =&gt; IsMenuVisible, ref _isMenuVisible, value); }
    }

    public Command ToggleMenuCommand { get; private set; }
  }
}</pre>
<p>A command that toggles a simple boolean property. I mean, how hard can it be, right? </p>
<h2>Leveling the playing field</h2>
<p>If you are coming from Windows behaviors, like I do, you are in for a surprise. Xamarin behaviors are a prime example of something that quacks like a duck and walks like a duck, can be a goose after all. Some things are a bit different and – like a goose – can bite you pretty badly. First of all, there is no standard binding context, and there is no AssociatedObject property to easily refer to. This can make things a bit complex when 'translating' behaviors from Windows to Xamarin and back, hence this base class to make sure we have the same - or at least a more similar - base </p><pre>using System;
using Xamarin.Forms;

namespace Wortell.XamarinForms.Behaviors.Base
{
  public abstract class BindableBehaviorBase&lt;T&gt; : Behavior&lt;T&gt; 
    where T : VisualElement
  {
    protected T AssociatedObject { get; private set; }

    protected override void OnAttachedTo(T bindable)
    {
      AssociatedObject = bindable;
      bindable.BindingContextChanged += Bindable_BindingContextChanged;
      base.OnAttachedTo(bindable);
    }

    protected override void OnDetachingFrom(T bindable)
    {
      bindable.BindingContextChanged -= Bindable_BindingContextChanged;
      base.OnDetachingFrom(bindable);
      AssociatedObject = null;
    }

    private void Bindable_BindingContextChanged(object sender, EventArgs e)
    {
      if (AssociatedObject != null)
      {
        BindingContext = AssociatedObject.BindingContext;
      }
    }
  }
}
</pre>It's a bit of an oddball class, but it's purpose is simple - after this has run, you can bind to any of the behavior's dependency properties, and in your code you can refer to a typed AssociatedObject, just like you would in Windows XAML behaviors. 
<h2>Getting a bit animated</h2>
<p>Now earlier in this blog post I mentioned the fact that behaviors doing <em>animations</em> probably need to know when a view is ready initializing, so they can initialize themselves. To get to this point, there is this base class on top of&nbsp; BindableBehaviorBase, with a similar ‘original name:</p><pre>using Xamarin.Forms;

namespace Wortell.XamarinForms.Behaviors.Base
{
  public abstract class ViewInitializedBehaviorBase&lt;T&gt; : BindableBehaviorBase&lt;T&gt; 
    where T : VisualElement
  {
    #region ViewIsInitialized Attached Dependency Property      
    public static readonly BindableProperty ViewIsInitializedProperty =
       BindableProperty.Create(nameof(ViewIsInitialized), typeof(bool), 
       typeof(ViewInitializedBehaviorBase&lt;T&gt;),
       default(bool), BindingMode.TwoWay,
       propertyChanged: OnViewIsInitializedChanged);

    public bool ViewIsInitialized
    {
      get { return (bool)GetValue(ViewIsInitializedProperty); }
      set { SetValue(ViewIsInitializedProperty, value); }
    }

    private static void OnViewIsInitializedChanged(BindableObject bindable, 
            object oldValue, object newValue)
    {
      var thisObj = bindable as ViewInitializedBehaviorBase&lt;T&gt;;
      thisObj?.Init((bool)newValue);
    }

    #endregion

    protected abstract void Init(bool viewIsInitialized);
  }
}</pre>
<p>When you bind the <em>behavior’s</em> ViewIsInitialized property to the <em>viewmodel’s</em> ViewIsInitialized property, the behavior knows ‘when the view is ready (or not anymore). Whatever, if the property in the view model changes, the behavior calls its (now abstract) method Init.</p>
<p>So what happens is</p>
<p>BaseContentPage –&gt; PageViewModelBase –&gt; (property binding) ViewInitializedBehaviorBase.Init –&gt; <br>&nbsp; Concrete Implementation.Init</p>
<h2>And finally - menu animations</h2>
<p>One more base class to go. I noticed pretty soon that animations handling the folding or scrolling of things almost always consider one property to be animated. So I created a yet another base class </p><pre>using Xamarin.Forms;

namespace Wortell.XamarinForms.Behaviors.Base
{
  public abstract class AnimateFoldBehaviorBase : 
    ViewInitializedBehaviorBase&lt;View&gt;
  {
    protected double FoldInPosition;
    protected double FoldOutPosition;

    protected VisualElement GetParentView()
    {
      var parent = AssociatedObject as Element;
      VisualElement parentView = null;
      if (parent != null)
      {
        do
        {
          parent = parent.Parent;
          parentView = parent as VisualElement;
        } while (parentView?.Width &lt;= 0 &amp;&amp; parent.Parent != null);
      }

      return parentView;
    }

    protected override void OnAttachedTo(View bindable)
    {
      base.OnAttachedTo(bindable);
      bindable.IsVisible = false;
    }

    private void ExecuteAnimation(bool show)
    {
      if (show)
      {
        AssociatedObject.IsVisible = true;
        ExecuteAnimation(FoldInPosition, FoldOutPosition, (uint)FoldOutTime);
      }
      else
      {
        ExecuteAnimation(FoldOutPosition, FoldInPosition, (uint)FoldInTime);
      }
    }

    protected abstract void ExecuteAnimation(double start, double end, 
      uint runningTime);

    public static readonly BindableProperty IsVisibleProperty =
       BindableProperty.Create(nameof(IsVisible), typeof(bool), 
       typeof(AnimateFoldBehaviorBase),
       false, BindingMode.OneWay,
       propertyChanged: OnIsVisibleChanged);

    public bool IsVisible
    {
      get { return (bool)GetValue(IsVisibleProperty); }
      set {SetValue(IsVisibleProperty, value); }
    }

    private static void OnIsVisibleChanged(BindableObject bindable, 
       object oldValue, object newValue)
    {
      var thisObj = bindable as AnimateFoldBehaviorBase;
      thisObj?.ExecuteAnimation((bool)newValue);
    }   

    // FoldInTime Attached Dependency Property      
 
    // FoldOutTime Attached Dependency Property      
  }
}</pre>
<p>This class handles a few important things. First of all, it gets the parent view – in a menu’s case the page. In fact, it finds the first object that has a width, thus a size. This is the behavior’s ‘playing field’. Then there is the ExecuteAnimation method, that actually <em>starts</em> the animation – or reverses it. Note also that the behavior actually <em>hides</em> the element that it’s animating – this whole setup assumes you will move something <em>into</em> view, while it’s not in view initially. You might notice that the Init method which is abstract in it's parent class is still not implemented. That happens only in the concrete class - that is actually pretty small, now all the ground work has been laid:</p><pre>using Wortell.XamarinForms.Behaviors.Base;
using Xamarin.Forms;

namespace Wortell.XamarinForms.Behaviors
{
  public class AnimateSlideDownBehavior : AnimateFoldBehaviorBase
  {
    protected override void Init(bool newValue)
    {
      if (newValue)
      {
        var parentView = GetParentView();
        if (parentView != null)
        {
          FoldInPosition = -parentView.Height;
          AssociatedObject.TranslationY = FoldInPosition;
        }
      }
    }

    protected override void ExecuteAnimation(double start, 
       double end, uint runningTime)
    {
      var animation = new Animation(
        d =&gt; AssociatedObject.TranslationY = d, start, end, Easing.SinOut);

      animation.Commit(AssociatedObject, "Unfold", length: runningTime,
        finished: (d, b) =&gt;
        {
          if (AssociatedObject.TranslationY.Equals(FoldInPosition))
          {
            AssociatedObject.IsVisible = false;
          }
        });
    }
  }
}
</pre>
<p>So on Init, the menu is moved up exactly it’s own height and - assuming it’s on top of the page - it will appear just outside the view. The actual animation code itself is laughably simple – it just animates over TranslationY, and when it find it’s ending at the FoldInPosition, it will make the animated object invisible</p>
<p>All that’s left now is defining the menu in XAML and then adding the behavior to it. It’s important to add the menu <em>after</em> the actual page content so it will be drawn over it. Otherwise it will just slide behind it, and that’s not very useful.</p><pre>&lt;!-- Menu --&gt;
&lt;ContentView Grid.Row="0" Grid.RowSpan="2"&gt;
<span style="color: #ff0000"><strong>  &lt;ContentView.Behaviors&gt;
    &lt;behaviors:AnimateSlideDownBehavior
      IsVisible="{Binding IsMenuVisible}"
      ViewIsInitialized="{Binding ViewIsInitialized}"
      FoldOutTime="400" FoldInTime="300"/&gt;
  &lt;/ContentView.Behaviors&gt;</strong></span>
  &lt;Grid&gt;
    &lt;Grid.RowDefinitions&gt;
      &lt;RowDefinition Height="75*"&gt;&lt;/RowDefinition&gt;
      &lt;RowDefinition Height="25*"&gt;&lt;/RowDefinition&gt;
    &lt;/Grid.RowDefinitions&gt;
    &lt;ContentView Style="{StaticResource MenuStyle}"&gt;
      &lt;StackLayout Style="{StaticResource ContentStyle}" 
        Orientation="Vertical" VerticalOptions="Start"&gt;
        &lt;Image Source="chevronup.png" HeightRequest="40" 
          VerticalOptions="Start" HorizontalOptions="Start"&gt;
          &lt;Image.GestureRecognizers&gt;
            &lt;TapGestureRecognizer Command="{Binding ToggleMenuCommand}"/&gt;
          &lt;/Image.GestureRecognizers&gt;
        &lt;/Image&gt;
        &lt;Label Text="Menu" Style="{StaticResource HeaderStyle}"
          VerticalOptions="Start"/&gt;
        &lt;Label Text="Here be menu content" 
         Style="{StaticResource MenuTextStyle}"&gt;&lt;/Label&gt;
      &lt;/StackLayout&gt;
    &lt;/ContentView&gt;

    &lt;!-- Leftover space --&gt;
    &lt;ContentView Grid.Row="1"  HorizontalOptions="Fill" VerticalOptions="Fill"&gt;
      &lt;ContentView.GestureRecognizers&gt;
        &lt;TapGestureRecognizer Command="{Binding ToggleMenuCommand}"/&gt;
      &lt;/ContentView.GestureRecognizers&gt;
    &lt;/ContentView&gt;
  &lt;/Grid&gt;
&lt;/ContentView&gt;</pre>
<p>Note the binding of ViewIsInitialized to ViewIsInitialized for the initialization, and of IsVisible to IsMenuVisible for the actual execution of the animation. Also notice the FoldOutTime and FoldInTime – the menu will fold out in 400, and fold in in 300ms. These are optional values – if you don’t specify them, the behavior will use default values. Finally, note the fact that the menu actually covers the whole screen, but the lower part is empty. Yet, if you tap that part, the menu will move away as well, as you would expect in an app.</p>
<p>The AnimateSlideInBehavior is nearly the same but animates TranslateX – just have a look at the <a href="https://github.com/LocalJoost/XamarinFormsDemos/tree/blog1" target="_blank">sample code</a>, it’s yours for the taking</p>
<h2>Some concluding remarks</h2>
<p>Of course you can also code these animations into code behind or in a control’s code behind, but that way you will need to copy and paste code into your views time and time again, and potentially you will need to fix the same bugs on multiple places. What I usually do is indeed make a control, but use the behavior in <em>that</em> and then re-use the control over multiple pages. Using a behavior decouples the code from a specific control or page, and you can re-use the dynamic behavior everywhere.</p>
<p>One final bit – the Xamarin iOS linker is still sometimes ‘optimizing’ away code, just like .NET Native, <a href="http://localjoost.github.io/solving-systemiofilenotfoundexception" target="_blank">something that already bit me last year</a>. So in the Wortell.XamarinForms there is this extremely odd class Initializer:</p><pre>namespace Wortell.XamarinForms
{
  public static class Initializer
  {
    public static void Init()
    {
    }
  }
}</pre>that indeed does completely nothing, except for being called from the iOS project's AppDelegate <pre>public override bool FinishedLaunching(UIApplication app, NSDictionary options)
{
    global::Xamarin.Forms.Forms.Init();
    global::Wortell.XamarinForms.Initializer.Init();
    LoadApplication(new App());

    return base.FinishedLaunching(app, options);
}</pre>Which still does nothing, but&nbsp; tricks the compiler into thinking the code is actually used (which is true) so the assembly actually gets packaged with the app. 
<p>I hope this blog will inspire you to try your hand at animations with Xamarin Forms as well. It’s actually pretty easy when you get the hang of it. And there is more to come on this blog.</p>
<p>Parts of this text appeared earlier on the <a href="http://www.wortell.nl/blog/" target="_blank">Wortell company blog, in Dutch</a></p>
