---
layout: post
title: Mixed Reality Toolkit vNext–dependency injection with extension services
date: '2018-12-08T13:15:00.000+01:00'
orgauthor: Joost van Schaik
tags:
- HoloLens
- MRTK-vNext
- Windows Mixed Reality
modified_time: '2018-12-08T14:29:46.363+01:00'
thumbnail: https://lh3.googleusercontent.com/-ia-FpXBcYxI/XAu1z4O3ioI/AAAAAAAAQik/0335F0-T4LogtlYzkIMB-v3O7qXlvB9ZgCHMYCw/s72-c/image_thumb%255B4%255D?imgmax=800
blogger_id: tag:blogger.com,1999:blog-5295746446529817470.post-8747334500105154236
blogger_orig_url: https://dotnetbyexample.blogspot.com/2018/12/mixed-reality-toolkit-vnextdependency.html
---

<h2>Intro</h2><p>The <a href="https://www.microsoft.com/en-us/windows/windows-mixed-reality" target="_blank"><a href="https://www.microsoft.com/en-us/windows/windows-mixed-reality" target="_blank">Mixed Reality Toolkit</a> vNext comes with an awesome mechanism for dependency injection. This also takes away a major pain point – all kinds of behaviors that are singletons that are called from everywhere, leading to all kind of interesting timing issues - and tightly coupled classes. This all ends wit extension services, which piggyback on the plugin structure of the MRKT-vNext. In this post I will describe how you make, configure and use such an extension service</p><h2>Creating an extension service</h2><p>A service that can be used by the extension service framework (and be found by the inspector dropdown that I will show later) needs to implement <strong>IMixedRealityExtensionService<em> </em></strong>at the very least. But of course we want to have the service make do something <em>useful</em> so I made a child interface:</p><pre style="font-size: 11px;">using Microsoft.MixedReality.Toolkit.Core.Interfaces;

namespace Assets.App.Scripts
{
    public interface ITestDataService : IMixedRealityExtensionService
    {
        string GetTestData();
    }
}</pre><p>the method GetTestData is the method we want to use.</p><p>Any class implementing IMixedRealityExtensionService needs to implement six methods and two properties. And to be usable by the framework, it needs to have this constructor:</p><p><strong>&lt;ClassName&gt;(string name, uint priority)</strong></p><p>To make this a little more simple, the MRKT-vNext contains a base class BaseExtensionService that provides default implementation for all the required stuff. And thus we can make a TestDataService very simple, as it a) implements all properties and b) forces us to provide the necessary constructor:</p><pre style="font-size: 11px;">using Microsoft.MixedReality.Toolkit.Core.Services;
using UnityEngine;

namespace Assets.App.Scripts
{
    public class TestDataService : BaseExtensionService, ITestDataService
    {
        public TestDataService(string name, uint priority) : base(name, priority)
        {
        }

        public string GetTestData()
        {
            Debug.Log("GetTestData called");
            return "Hello";
        }
    }
}
</pre><h2>Registering the service in the framework</h2><p>Check if a custom profile has been selected. Assuming you have followed the procedure I described in my <a href="http://localjoost.github.io/2018/12/07/mixed-reality-toolkit-vnextsetting-up.html" target="_blank">previous post</a>, you can do you this by selecting the MixedRealityToolkit game object in your scene and then double-clicking the “Active Profile” field</p><p><a href="https://lh3.googleusercontent.com/-rCMndZ5wuoo/XAu1zFK2NkI/AAAAAAAAQig/Fdvl7i_4ejM4MPKNcjlOZ2N8-TdGlIhbQCHMYCw/s1600-h/image%255B6%255D"><img width="350" height="39" title="image" style="border: 0px currentcolor; border-image: none; display: inline; background-image: none;" alt="image" src="https://lh3.googleusercontent.com/-ia-FpXBcYxI/XAu1z4O3ioI/AAAAAAAAQik/0335F0-T4LogtlYzkIMB-v3O7qXlvB9ZgCHMYCw/image_thumb%255B4%255D?imgmax=800" border="0"></a></p><p>If the UI is read-only, there’s no active custom profile. Check if there’s a profile in MixedRealityToolkit-Generated/CustomProfiles and drag that on top of the ActiveProfile field of the MixedRealityTool object. If there’s no custom profile at all, Please refer to my <a href="http://localjoost.github.io/2018/12/07/mixed-reality-toolkit-vnextsetting-up.html" target="_blank">previous blog post</a>. </p><p>Scroll all the way down to Additional Service Providers. </p><p><a href="https://lh3.googleusercontent.com/-k46h4lVpYG0/XAu10_933kI/AAAAAAAAQio/D2MKJxh3M5A56qQILHoj7PfOge35zDHcACHMYCw/s1600-h/image%255B10%255D"><img width="334" height="45" title="image" style="display: inline; background-image: none;" alt="image" src="https://lh3.googleusercontent.com/-FfRkSK1DJQk/XAu114FS_8I/AAAAAAAAQis/y72VILD_rbIlEUxYGzXT4gIRLifmV11FgCHMYCw/image_thumb%255B6%255D?imgmax=800" border="0"></a></p><p>Click the <strong>&lt;/&gt;</strong> button. This creates a MixedRealityRegisteredServiceProvidersProfile in <br>MixedRealityToolkit-Generated/CustomProfiles and shows this editor.</p><p><a href="https://lh3.googleusercontent.com/-slFNDcYNZ2Y/XAu12rjyiwI/AAAAAAAAQiw/gS_J2MP7KtYWHyQtOA6GphXRNt1zQCppgCHMYCw/s1600-h/image%255B15%255D"><img width="330" height="450" title="image" style="border: 0px currentcolor; border-image: none; display: inline; background-image: none;" alt="image" src="https://lh3.googleusercontent.com/-X90syC7h0ac/XAu13WuwInI/AAAAAAAAQi0/hmIl23vKP6AF0TBs_AOSdx3_w2ujlS85QCHMYCw/image_thumb%255B9%255D?imgmax=800" border="0"></a></p><p>Click “+ Register a new Service Provider”. This results in a “New Configuration 8” that if you expand it, looks like this:</p><p><a href="https://lh3.googleusercontent.com/-LT_-i8qzFnE/XAu14BIeZQI/AAAAAAAAQi4/FOAyMGjh0m04VbQnXf2nj7J2ROKgc8nXACHMYCw/s1600-h/image%255B20%255D"><img width="310" height="90" title="image" style="border: 0px currentcolor; border-image: none; display: inline; background-image: none;" alt="image" src="https://lh3.googleusercontent.com/-fteuJRxuHKg/XAu15envc8I/AAAAAAAAQi8/EcyKmxoOfIoar3ole2Sj6S_AbVTollMpgCHMYCw/image_thumb%255B12%255D?imgmax=800" border="0"></a></p><p>If you click the “Component Type” drop down you should be able to select “Assets.Apps.Scripts” and then “TestDataService”. </p><p><a href="https://lh3.googleusercontent.com/-7pOyHQQDAwU/XAu16PcYfmI/AAAAAAAAQjA/0iqZdupkSzgBGvjqzLB8Y8kdRSkTktnxACHMYCw/s1600-h/image%255B27%255D"><img width="400" height="187" title="image" style="border: 0px currentcolor; border-image: none; display: inline; background-image: none;" alt="image" src="https://lh3.googleusercontent.com/-17Ubc4dZixk/XAu16-n5nCI/AAAAAAAAQjE/usL-p3lrXV4ZcI7kXYFsISGOJOm2t_QTACHMYCw/image_thumb%255B17%255D?imgmax=800" border="0"></a></p><p>I also tend to give this component a bit more understandable name so the final result looks like this:</p><p><a href="https://lh3.googleusercontent.com/-UO1Kgdslrww/XAu17s8jq9I/AAAAAAAAQjI/_0xZJT1V8y0xKmnnOSY1SOaLQg293PY4QCHMYCw/s1600-h/image%255B32%255D"><img width="310" height="84" title="image" style="border: 0px currentcolor; border-image: none; display: inline; background-image: none;" alt="image" src="https://lh3.googleusercontent.com/-urt0YM8Ppsg/XAu18vZ04LI/AAAAAAAAQjM/gQ0yAIPPp8wLglvRHdxP8zOKb2RsPO-bQCHMYCw/image_thumb%255B20%255D?imgmax=800" border="0"></a></p><h2>Calling the service from code</h2><p>A <em>very</em> simple piece of code shows how you can then retrieve the and use the service from the MixedRealityToolkit: </p><pre style="font-size: 11px;">using Microsoft.MixedReality.Toolkit.Core.Services;
using UnityEngine;

namespace Assets.App.Scripts
{
    public class TestCaller : MonoBehaviour
    {
        private void Start()
        {
            var service  = MixedRealityToolkit.Instance.GetService&lt;ITestDataService&gt;();
            Debug.Log("Service returned " + service.GetTestData());
        }
    }
}</pre><p>Notice I can retrieve the implementation using my own interface type. This very is similar to what we are used to do in ‘normal’ IoC containers like Unity (the other one), AutoFac, SimpleIoC. If you attach this behaviour to any game object in the hierarchy (I created an empty object “Managers” to this extent), and run this project, you will simply see this in the console:</p><p><a href="https://lh3.googleusercontent.com/-Y6WEZ3NAFRc/XAu19EXPgRI/AAAAAAAAQjQ/uFVifshQJTAvGcUehNFMwdyVyxKMep3GgCHMYCw/s1600-h/image%255B53%255D"><img width="165" height="49" title="image" style="border: 0px currentcolor; border-image: none; display: inline; background-image: none;" alt="image" src="https://lh3.googleusercontent.com/-ycGaDP_0suI/XAu19414SWI/AAAAAAAAQjU/Gd9M1iiOSGUfdmlUqkpEVb1oih0K49DeACHMYCw/image_thumb%255B39%255D?imgmax=800" border="0"></a></p><p>It’s not spectacular, but it proves the point that this is working as expected</p><h2>Conclusion</h2><p>MRTK-vNext provides a very neat visual select mechanism for wiring up dependency injection that is very easy to use. I can also easily retrieve implementations of the service using an interface, just like any other IoC platform. The usage of profiles makes it very flexible and reusable. This alone makes it a great framework, and then I have not even looked into the cross-platform stuff. That I will do soon. Stay tuned.</p><p>In the mean time, <a href="https://github.com/LocalJoost/MRTKvNextTest1" target="_blank">the demo project can be found here.</a></p>