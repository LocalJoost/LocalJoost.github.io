---
layout: post
title: Enabling basic OpenLayers pinch zooming for Internet Explorer 10 touch events
date: '2013-03-27T18:43:00.001+01:00'
orgauthor: Joost van Schaik
tags:
- css
- OpenLayers
- Mapping
- html
- Javascript
- touch
modified_time: '2013-03-27T19:35:28.640+01:00'
blogger_id: tag:blogger.com,1999:blog-5295746446529817470.post-7437229720049471878
blogger_orig_url: https://dotnetbyexample.blogspot.com/2013/03/enabling-basic-openlayers-pinch-zooming.html
---

<p>A phenomenon described by the term <a href="http://www.bing.com/search?q=webkit+monoculture" target="_blank">‘webkit monoculture’</a> is causing quite some concern in the web development community. A lot of web developers are basically coding for webkit and webkit only, or more specifically Safari on IOS. HTML5 and standards are great, but certain parts of the web development stack are moving back to a ‘works on my environment’ status <a href="http://www.ie6countdown.com/" target="_blank">that we just were getting rid of</a>. This phenomenon rears it’s ugly head itself on all kind of places, including in the <a href="http://www.openlayers.org/" target="_blank">OpenLayers</a> toolkit that I am using for my work at <a href="http://www.vicrea.nl" target="_blank">Vicrea</a>.</p> <p>For those not familiar with OpenLayers: think Google Maps, but then with real GIS functionality, without commercial licensing, without ads in the map, and without all kind of legal strings attached. Pure open source client side web GIS. With the advent of touch devices its community added some basic touch functionality to it, like pinch zoom. That works very smooth, provided – you guessed it – you work on a web kit based browser. Microsoft, in all its wisdom, has chose to implement touch events in a completely different way. As to why this is, and what exactly is standard or not – that is not exactly my concern here. I am making a web GIS that is not supported my Windows 8 touch devices and <a href="http://www.microsoft.com/windowsphone/?ocid=aff-n-we-loc--ITPRO40939&amp;WT.mc_id=aff-n-we-loc--ITPRO40939" target="_blank">Windows Phone</a> 8. That, of course, is unacceptable to me ;-)</p> <p>So I created a little OpenLayers style control that adds pinch zoom to Internet Explorer 10. It’s pure JavaScript and a little primitive – it’s basically zooming in on the map center, and not on the point between your fingers, but it’s working pretty well IMHO.</p> <p>It also works pretty <em>simple</em>: upon the activate command, it hooks itself onto two events of the map’s layerContainerDiv – MSPointerDown and MSGestureChanged. The first one is fired at the first touch point going down, the second one when MSGesture recognizes an MSGestureChanged. Important is also setting the map’s fractionalZoom property to true.</p><pre>OpenLayersWindowsPinchZoom = OpenLayers.Class(OpenLayers.Control,
  {
    autoActivate: true,

    gesture: null,

    defaultHandlerOptions: {},

    initialize: function (options)
    {
      this.handlerOptions = OpenLayers.Util.extend({}, this.defaultHandlerOptions);
      OpenLayers.Control.prototype.initialize.apply(this, options);
    },

    activate: function ()
    {
      if (OpenLayers.Control.prototype.activate.apply(this, arguments))
      {
        if (window.navigator.msPointerEnabled)
        {
          this.map.fractionalZoom = true;

          this.gesture = new MSGesture();
          this.gesture.target = this.map.layerContainerDiv;
          var self = this;

          this.gesture.target.addEventListener("MSPointerDown", function (evt)
          {
            self.gesture.addPointer(evt.pointerId);
          });

          this.gesture.target.addEventListener("MSGestureChange", function (evt)
          {
            // Make scale result smaller to prevent high zoom speeds.
            if (evt.scale !== 1)
            {
              var scale = 1;
              if (evt.scale &gt; 1)
              {
                scale = (evt.scale - 1) / 4 + 1;
              }
              else
              {
                scale = 1 - ((1 - evt.scale) / 4);
              }
              // map.zoomTo is buggy as hell so I use this convoluted way to 
              // calculate a new zoom area
              var resolution = self.map.getResolutionForZoom(self.map.zoom * scale);
              var bounds = self.map.calculateBounds(self.map.getCenter(), resolution);
              self.map.zoomToExtent(bounds);
            }
          });
        }
        return true;
      }
      else
      {
        return false;
      }
    },

    CLASS_NAME: "OpenLayersWindowsTouch"
  }
);
</pre>
<p>The MSGestureChanged event has a scale, which is a number either bigger (zoom in) or smaller (zoom out) than 1. After that it’s simply calling some standard map functions to calculate the new display area and fire away. The most logical one to use would be map.ZoomTo, but that completely messes up the map tile layout after a few times and this workaround via the resolution calculation prevents that. I assume there is a bug in the zoomTo code.</p>
<p>There is another detail – to prevent Internet Explorer to handle the zoom events itself, you have to mark the div in which the map will come with css style:</p><pre>-ms-touch-action: none</pre>
<p>I did that inline for the sake of simplicity ;-)</p><pre>&lt;div id="map2" class="smallmap" style="-ms-touch-action: none"&gt;&lt;/div&gt;</pre>
<p>As for creating the map with the control enabled: this is a normal map with just the standard controls:</p><pre>map1 = new OpenLayers.Map('map1', 
	 {controls: [new OpenLayers.Control.Navigation(), 
                       new OpenLayers.Control.PanZoomBar()], 
	  numZoomLevels: 15});</pre>while the second one sports my new control as well:<pre>map2 = new OpenLayers.Map('map2', 
	 {controls: [new OpenLayers.Control.Navigation(), 
		  new OpenLayers.Control.PanZoomBar(),
		  <font color="#ff0000"><u>new OpenLayersWindowsPinchZoom()</u></font>], 
	  numZoomLevels: 15});</pre>
<p><a href="http://www.schaikweb.net/dotnetbyexample/Enabling-basic-OpenLayers-pinch-zooming-_DF02/image.png"><img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; float: left; padding-top: 0px; padding-left: 0px; margin: 0px 7px 0px 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="image" align="left" src="http://www.schaikweb.net/dotnetbyexample/Enabling-basic-OpenLayers-pinch-zooming-_DF02/image_thumb.png" width="260" height="305"></a>And that’s all there is to it. For the OpenLayers purists: yes, I am aware that I don’t implement destroy and potentially create memory leaks. I just wanted to kick off IE10 support. I hope the ‘real’ OpenLayers developers do better and now start supporting IE10 by themselves ;-)</p>
<p>I have made a little live demo site which looks like showed on the left. <a href="http://www.schaikweb.net/dotnetbyexample/ie10olpinchzoom/demowinpinch.html" target="_blank">You can watch it live here</a> and download a zip file containing <a href="http://www.schaikweb.net/dotnetbyexample/ie10olpinchzoom/OpenLayersWindowsPinchZoom.zip" target="_blank">all the necessary file in one go here</a>.</p>
<p>The control has been tested successfully on a Nokia Lumia Windows Phone 8, a Microsoft RT and a Microsoft Surface Pro. </p>  