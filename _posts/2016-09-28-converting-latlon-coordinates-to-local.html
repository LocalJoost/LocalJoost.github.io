---
layout: post
title: Converting lat/lon coordinates to local coordinates for HoloLens apps
date: '2016-09-28T17:24:00.001+02:00'
orgauthor: Joost van Schaik
tags:
- UWP
- HoloLens
- Mapping
modified_time: '2016-09-30T08:58:33.716+02:00'
blogger_id: tag:blogger.com,1999:blog-5295746446529817470.post-1281929235433839355
blogger_orig_url: https://dotnetbyexample.blogspot.com/2016/09/converting-latlon-coordinates-to-local.html
---

<p>This is going to be a bit of a theoretical story, but I feel it’s a necessary as a precursor to my promise to explain in detail how I made the <a href="ms-windows-store://pdp/?ProductId=9NBLGGH52SZP">AMS HoloATC app</a>. So bear with me.  <p>One of the challenges when it comes to showing geo-positioned data in a HoloLens is that is most of this type of data comes in Lat/Lon (and optional Alt – for altitude) format. The UWP Map component knows how to handle it, but if you want to use this kind of data in a HoloLens you will need some way to convert to the X-Y-Z system Unity uses.  <p>Now there are two approaches. The first one is to go for the full 3D experience and you project the coordinates relative to a <i>globe</i>. Although is awesome for demoes, it also has the drawback that it may not be easy to see relative heights over larger distances in what is in essence a curved plane. In my app I take the Netherlands – an area of 300 by 200 km, the largest part more or less North-South, and condense that by a factor of 15000 to about 20 x 13 meters. The curvature of the Earth would cause the airplanes to rise from the edges of the view, and then come down again as they head for approach and landing.  <p><img style="float: right; display: inline" src="https://www.laetusinpraesens.org/docs10s/images/fantasy_files/tangent-plane_up.png" width="240" align="right" height="158">The second approach is to pretend the Earth is flat in the Netherlands (which is kind of true, but and in a different way-people who have ever visited us will understand why) and use a <i>tangential plane</i> that hits the Earth on a certain spot. This is the approach I took. For the spot where the plane hits the Earth I took what according to Google Maps is the center of Amsterdam airport (aka Schiphol) -&nbsp; 52.307687, 4.767424, 0 (lat/lon/alt)*. A very useful site for finding lat/lon coordinates of places on Earth is <a href="http://www.latlong.net/">this one</a>. Click on the map or enter a name and presto.  <p>Projecting an airplane to a globe or this tangential plane requires more math than I know. Although I worked in GIS for over 20 years I was never formally trained for it that and I was never a math wizard anyway. Fortunately, some guy called <a href="https://gist.github.com/govert">Govert van Drimmelen</a> – I presumed him to be Dutch as well based on his name, but he is actually from South Africa – has posted a <a href="https://gist.github.com/govert/1b373696c9a27ff4c72a">GitHub gist</a> that does exactly what you need. It actually supports <i>both</i> approaches (projection to a globe and to a tangential plane). I made a <a href="https://gist.github.com/LocalJoost/fdfe2966e5a380957d1c90c462fd1e5c">fork of it</a> that only gets rid of the missing Util.DegreesToRadians, the tests and other stuff that is not used, but is essentially the same.  <p>But there are still two caveats, and they both have to do with altitude. I put the center of Schiphol on the 0,0,0 position in Unity’s coordinate system, and then wrote this test code: <pre>double x, y, z;
GpsUtils.GeodeticToEnu(52.307687, 4.767424, 0, 52.307687, 4.767424, 0, out x, out y, out z);
Assert.IsTrue(x == 0 &amp;&amp; y == 0 &amp;&amp; z == 0);
</pre>
<p>The first coordinate is the coordinate I want to project, the second one is the place where the tangential plane is hitting the ground. If I put both at the same place, the method should return 0,0,0. And indeed it does. Hurray. 
<p>Now let’s head over to the city of Leeuwarden, some 121 km North-East from Schiphol (<a href="https://www.freemaptools.com/measure-distance.htm">this is a useful simple website for measuring distances</a>) at lat, lon = 53.201233, 5.799913. As I have no idea what to expect, let’s first print out the results before testing <pre>GpsUtils.GeodeticToEnu(53.201233, 5.799913, 0, 52.307687, 4.767424, 0, out x, out y, out z);
Debug.WriteLine($"{x},{y},{z}");
</pre>
<p>Result: 68991.988451593,99923.1412132109,-1155.45361490022. The output is apparently in meters. Nice. So… 100km to the North and 69km to the West. If you do Pythagoras on those first two values, you get indeed about 121000. Awesome. So that seems to work as well. But… 1155 down? Still the curvature of the Earth, I guess. Apparently when you go 121 km to the North-East, you end up 1155 below the horizon of someone standing on the original place. I think. So when I project my plane I use X for X, Y for Y, and the original altitude for Z. But this leads to another problem. 
<p>First of all, one unit is a meter in a HoloLens (or appears to be – let’s not get metaphysical). If I were to use X/Y/Alt directly, an airplane approaching from the direction of Leeuwarden at 3km would be some 121km from my point of view – and at 3km height. Even if I used 1:1 models it would be invisible. That does not help giving an Air Traffic Controller (ATC) a nice 3D view of the area around his or her airport of condern. So I divide X and Y by 15000. Result for an airplane about Leeuwarden is this: 4.59946589677287,6.6615427475474 
<p>So an airplane that is in real life about 121km from me appears about 7 meters from me, forward and quite a bit to the right. As airplanes on approach for an airport (at least around Schiphol) are moving within 20km around the airport this makes the busiest part of air traffic happen in an apparent space of about 2.5x2.5 meters. That looks good to me. But if I would use the same scale factor on the <i>height</i>, and airplane flying 3km would be 20cm from the ground. At final approach, say at about 500m, it would be a mere 3cm from the ground. At 10km – cruise altitude, and not particularly interesting to and ATC - it would still be a little short of 70cm. Our poor ATC would have to look very carefully to see height differences between aircraft on final approach ;). So I opted to scale down the height considerably less – by dividing that by only 2000. That puts an aircraft on 500m at 25cm, on 3km it is at 1.5m, and 10km is at 5m – still well within visual range, but literally flying <i>way</i> over your head, which is exactly what you want, as it is not of immediate concern for an ATC handling the arrivals and departures on an airport. The only drawback is that aircraft seem to climb at impossible steep trajectories when taking off, but I think that’s ok. 
<p>So this is how I convert and transform aircraft flight data into what I think a format and space that makes it usable for an ATC wearing a HoloLens. The fun part of it is that when I hook up the app to live data and put Schiphol to the side of the room, the city where I live is more or less where the living table is. It’s pretty awesome to see airplanes coming from Schiphol and moving over that table – because in certain conditions, and when I open a window, I can actually <i>hear the rumble of engines of the actual airplane</i> outside when it passes over my house at 3km height ;) 
<p>As I wrote earlier, a very theoretical and perhaps even dry piece of text. I hope it’s useful for other people thinking about using geo-positioned data in HoloLens. I am still a GIS nut at heart, although I don’t work in GIS anymore. I wonder if other people maybe have better approaches. 
<p>*<sup>Technically that is not correct - Schiphol is about 4.5 meters below sea level. Do not be alarmed. We have excellent dunes, dams, and other things to keep the wet bit where it belongs, i.e. not where we live. That is, for the time being ;)</sup></p>