---
layout: post
title: Querying the Windows Phone 8.1 map when there are child objects over it
date: '2014-08-13T22:26:00.001+02:00'
orgauthor: Joost van Schaik
tags:
- Windows phone 8.1
- Mapping
- wpnl
- wpdev
modified_time: '2014-10-02T11:10:54.889+02:00'
blogger_id: tag:blogger.com,1999:blog-5295746446529817470.post-2173880387369736179
blogger_orig_url: https://dotnetbyexample.blogspot.com/2014/08/querying-windows-phone-81-map-when.html
comment_issue_id: 188
---

<p>With the <a href="http://www.microsoft.com/windowsphone/?ocid=aff-n-we-loc--ITPRO40939&amp;WT.mc_id=aff-n-we-loc--ITPRO40939" target="_blank">Windows Phone</a> 8.1 SDK came (yet again) an improved Map Control. This brought, among other things, the MapIcon. In ye olde days, the map could only draw lines and polygons natively – when you had to draw icons you had to add child objects to the map itself, which were drawn by the UI thread and not by the map. This is slower and eats more resources.</p> <p><a href="http://www.schaikweb.net/dotnetbyexample/Que.1-map-when-there-are-child-objects-o_132AE/image.png"><img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; float: right; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="image" src="http://www.schaikweb.net/dotnetbyexample/Que.1-map-when-there-are-child-objects-o_132AE/image_thumb.png" width="214" align="right" height="354"></a>The new map still offers this possibility. And sometimes we need it, too, for a couple of reasons. First of all, a MapIcon can only display an image and an optional label. Second, MapIcons are drawn on the map using a ‘best effort’, which mean overlapping icons don’t get displayed at all and – worse – if you query the map, using the <a href="http://msdn.microsoft.com/en-us/library/windows.ui.xaml.controls.maps.mapcontrol.findmapelementsatoffset.aspx" target="_blank">FindMapElementsAtOffset</a> method, they are not found either.</p> <p>So in some cases we just need to resort to drawing XAML elements by adding to the map’s Children collection – an option, which luckily has been improved tremendously as we now, for instance, can <a href="http://www.visuallylocated.com/post/2014/08/13/Bind-a-collection-of-items-to-the-Windows-Phone-MapControl.aspx" target="_blank">data bind these elements using the MapItemsControl, as explained by my smart fellow MVP Shawn Kendrot</a>. Before 8.1, we needed the Windows Phone Toolkit for that.</p> <p>But I noticed something very odd. I have been trained to use the MapTapped event to trap the location where the user tapped, as the Tapped event is being trapped by the map itself. It never fires. So I used MapTapped, and then FindMapElementsAtOffset to query the map;</p> <p>But to my dismay I also discovered that the MapTapped event does not fire either when you tap on a location where a child object is displayed. Ergo – if you tap on the cross where the Windows Phone logo is displayed, nothing happens. So how am I to find out what’s underneath there?</p> <p>After some trashing around I stumbled upon the answer – if you tap on a child element that’s on the map – not the MapTapped, but the <em>Tapped</em> event fires. “The event that never fires” comes to the rescue. In addition, the Tapped event on the child object <em>itself</em> fires. So I created the following method to query the map:</p><pre>private void QueryMap(Point offset)
{
  foreach (var obj in MyMap.FindMapElementsAtOffset(offset))
  {
    Debug.WriteLine(obj.GetType());
  };
}</pre>The regular method to trap MapTapped: <pre>private void MyMap_OnMapTapped(MapControl sender, MapInputEventArgs args)
{
  Debug.WriteLine("MyMap.MapTapped occurred");
  QueryMap(args.Position);
}</pre>
<p>And a method to trap Tapped when that occurs, and that also routes to the QueryMap method, with a little help from the GetPosition event method:</p><pre>private void MyMap_OnTapped(object sender, TappedRoutedEventArgs e)
{
  Debug.WriteLine("MayMap.Tapped occurred");
  QueryMap(e.GetPosition(MyMap));
}</pre>
<p>And because the events <em>never</em> fire simultaneously, you will see the map finds one PolyLine when you tap on a line just next to the symbol, will and it fill find two lines (the crossing of both) when you tap on the symbol- but never will you get a double hit from both events.</p>
<p>By attaching to the Tapped event of the <em>Child </em>object I can <em>also</em> detect if the symbol <em>itself</em> is tapped:</p><pre>var childObj = new Image { 
  Source = new BitmapImage(new Uri("ms-appx:///Assets/wplogo.png")) };
MapControl.SetNormalizedAnchorPoint(childObj, new Point(0.5, 0.5));
MapControl.SetLocation(childObj, p5);
MyMap.Children.Add(childObj);
childObj.Tapped += ChildObj_Tapped;



void ChildObj_Tapped(object sender, TappedRoutedEventArgs e)
{
  Debug.WriteLine("ChildObj.Tapped occurred");
}
</pre>
<p>And thus we can find everything on the map, provided you attach the right methods to the right events. The MapTapped/Tapped combo of the map is an odd one but once you know how to do it – a few extra lines of code does it all.</p>
<p><a href="http://www.schaikweb.net/dotnetbyexample/TapDemo.zip" target="_blank">A demo app demonstrating the whole concept can be found here.</a>The only thing it does is write things to the debug console when you do something, so pay attention what happens there ;-)</p>  
