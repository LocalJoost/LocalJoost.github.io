---
layout: post
title: Build for both-Reflection bits & pieces for Windows Phone 8 and Windows 8
date: '2013-11-09T22:01:00.001+01:00'
author: Joost van Schaik
tags:
- Windows Phone 8
- reflection
- wpdev
- dotnetmag
- Windows 8
- WinRt
- Win8nl
modified_time: '2014-01-25T11:44:31.046+01:00'
blogger_id: tag:blogger.com,1999:blog-5295746446529817470.post-6063511929806806497
blogger_orig_url: https://dotnetbyexample.blogspot.com/2013/11/build-for-both-reflection-bits-pieces.html
---

<p>This is a bit of an odd post – it’s the things I learned while porting <a href="http://whydoidoit.com/silverlight-serializer/" target="_blank">SilverlightSerializer 2</a> from <a href="http://www.microsoft.com/windowsphone/?ocid=aff-n-we-loc--ITPRO40939&amp;WT.mc_id=aff-n-we-loc--ITPRO40939">Windows Phone</a> to <a href="http://windows.microsoft.com/en-US/windows-8/release-preview?ocid=aff-n-we-loc--ITPRO40939&amp;WT.mc_id=aff-n-we-loc--ITPRO40939" target="_blank">Windows 8</a> Store apps code. For those who don’t know what that is – it’s a very fast serializer, created by the brilliant <a href="http://www.twitter.com/mike_talbot" target="_blank">Mike Talbot</a> that’s able to store complex objects graphs in a very compact binary format. I use it to store an app’s state by simply serializing the view model graph to storage. For my (now) only Windows Store app I <a href="http://dotnetbyexample.blogspot.nl/2012/07/using-provisional-port-of.html" target="_blank">made a half-*ssed attempt to convert the much simpler SilverlightSerializer&nbsp; v1</a> last year – but that’s slower and much less capable – especially my port. I was very much in a hurry then, so I cut out everything I did not need.</p> <p>Anyway – SilverlightSerializer is a big chunk of reflection code. To get it to work in Windows Store apps, I had to change quite a lot of things – but then again a lot less than I thought. Even more shocking was the fact it worked without any problems when I linked the adapted code <em>back</em> to my Windows Phone project. That’s the power of the common Windows Runtime – no #if WINDOWS_PHONE preprocessor statements here!</p> <p>So anyway, here’s what I learned. I wrote it in a kind of boring old-new style, but I found very little on this subject on the web, so I hope this is useful for people digging into reflection on Windows Store apps and hitting the wall when trying to do it ‘the new way’.</p> <p><font size="4">Properties and Fields</font></p> <p><strong><u>Get an object’s properties:</u></strong></p> <ul> <li>Old code: Type<strong>.GetProperties()</strong>  <li>New code: Type<strong>.GetRuntimeProperties()</strong></li></ul> <p><strong><u>Get a single property:</u></strong></p> <ul> <li>Old code: Type<strong>.</strong><strong>GetProperty("MyProperty")</strong>  <li>New code: Type<strong>.GetRuntimeProperty("MyProperty")</strong></li></ul> <p><strong><u>Get a property’s get method</u></strong></p> <ul> <li>Old code: PropertyInfo.<strong>GetGetMethod(); </strong> <li>New code: PropertyInfo.<strong>GetMethod;</strong></li></ul> <p><strong><u>Get a property’s set method</u></strong></p> <ul> <li>Old code: PropertyInfo.<strong>GetSetMethod(); </strong> <li>New code: PropertyInfo.<strong>SetMethod;</strong></li></ul> <p><strong><u>Get public non-static properties that can be get and set</u></strong><!--EndFragment--></p> <ul> <li>Old code:Type<strong>.GetProperties(BindingFlags.Instance | BindingFlags.Public).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Where(p =&gt; p.GetSetMethod() != null));</strong>  <li>New code:Type<strong>.GetRuntimeProperties().<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Where(p=&gt; p.GetMethod != null &amp;&amp; p.SetMethod != null &amp;&amp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !p.SetMethod.IsStatic &amp;&amp; !p.GetMethod.IsStatic &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p.GetMethod.IsPublic &amp;&amp; p.SetMethod.IsPublic);</strong></li></ul> <p><strong><u>Get an object’s Fields:</u></strong></p> <ul> <li>Old code: Type<strong>.GetFields()</strong>  <li>New code: Type<strong>.GetRuntimeFields()</strong></li></ul> <p><strong><u>Get a single Field:</u></strong></p> <ul> <li>Old code: Type<strong>.</strong><strong>GetField("MyProperty")</strong>  <li>New code: Type<strong>.GetRuntimeField("MyProperty")</strong></li></ul> <p>You can already see two patterns here – in stead of GetXYZ you do GetRuntimeXYZ. This “Runtime” indicates all an objects has available on <em>runtime</em> – that is, both it’s own properties, methods etc. <em>and those of it’s parents.</em> The other pattern is that in the Windows Runtime there is a tendency to use <em>properties</em> in stead of zero-parameter get methods.</p> <p><font size="4">Attributes</font></p> <p><u><strong>Determine whether a property has a custom attribute or not</strong></u></p> <ul> <li>Old code: PropertyInfo.<strong>GetCustomAttributes(typeof(DoNotSerialize), true).Any()</strong>  <li>New code: PropertyInfo<strong>.GetCustomAttribute&lt;DoNotSerialize&gt;(true) != null</strong></li></ul> <p><font size="4">Type info</font></p> <p><strong><u>Determine if a type is an enum</u></strong></p> <ul> <li>Old code: Type.<strong>IsEnum</strong>  <li>New code: Type.<strong>GetTypeInfo().IsEnum</strong></li></ul> <p><u><strong>Determine if a type is a generic type</strong></u></p> <ul> <li>Old code: Type.<strong>IsGenericType</strong>  <li>New code: Type.<strong>GetTypeInfo().IsGenericType</strong><!--EndFragment--></li></ul> <p><u><strong>Determine a type’s generic arguments</strong></u></p> <ul> <li>Old code: Type.<strong>GetGenericArguments()</strong> <li>New code: Type.<strong>GetTypeInfo().GenericTypeArguments<!--EndFragment--></strong></li></ul> <p><u><strong>Find a type’s default constructor</strong></u></p> <ul> <li>Old code:Type.<strong>GetConstructor(new Type[] { });</strong>  <li>New code: Type.<strong>GetTypeInfo().DeclaredConstructors.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FirstOrDefault(p =&gt; !p.GetParameters().Any());</strong></li></ul> <p><u><strong>Determine if a type implements an interface</strong></u></p> <ul> <li>Old code: Type.<strong>GetInterface("IEnumerable", true) != null;</strong>  <li>New code: <strong>GetTypeInfo().ImplementedInterfaces.FirstOrDefault(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p =&gt; string.Compare(p.Name, name, ignoreCase? <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal)==0);</strong></li></ul> <p>I must admit being a bit lazy on this one – this was used quite a number of times in SilverlightSerializer, so I made the following extension method</p><pre>using System;
using System.Linq;
using System.Reflection;

namespace WpWinNl.Utilities
{
  public static class TypeExtensions
  {
    public static Type GetInterface(this Type type, string name, bool ignoreCase)
    {
      return type.GetTypeInfo().ImplementedInterfaces.FirstOrDefault(
        p =&gt; string.Compare(p.Name, name, ignoreCase? 
            StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal)==0) ;
    }
  }
}
</pre>
<p>and was done with it ;-). Beware – this is not something I recommend – making the <em>new</em> API compatible with the <em>old</em>. Rather, make it the other way around. But for porting existing code – especially code you did not write yourself – this can be a helpful way to save time.</p>
<p><font size="4">Miscellaneous</font></p>
<p><u><strong>Creating delegates</strong></u></p>
<ul>
<li>Old code<strong>: Delegate.CreateDelegate(typeof(DelegateType), MethodInfo);</strong></li>
<li>New code:<strong> MethodInfo.CreateDelegate(typeof(DelegateType));</strong></li></ul>
<p>A MethodInfo is something you would get out of for instance PropertyInfo.GetMethod. I must admit to code in SilverlightSerializer is quite complex at this point, and I don’t understand the whole detail. But this seems to work, and I suggest people more interested in the details to have a look at the code. I will post the whole shebang soon. </p>
<p>Sorry, no sample this time ;-)</p>  