---
layout: post
title: A HoloLens helper class to get a position dead ahead of the user–on a physical
  object or at a max distance
date: '2017-06-27T13:45:00.001+02:00'
author: Joost van Schaik
tags:
- UWP
- HoloLens
- Unity3D
modified_time: '2017-06-27T17:18:52.866+02:00'
thumbnail: https://lh3.googleusercontent.com/-JgHMb0S27qY/WVJFV3yJVlI/AAAAAAAAO9Y/iUCpxGL38mk0uN2z8rn-yUAMIG3iTo2fgCHMYCw/s72-c/image_thumb%255B1%255D?imgmax=800
blogger_id: tag:blogger.com,1999:blog-5295746446529817470.post-4912135930703015673
blogger_orig_url: https://dotnetbyexample.blogspot.com/2017/06/a-hololens-helper-class-to-get-position.html
---

<p>This is a little tidbit I use in a lot of apps, for instance in the <a href="http://dotnetbyexample.blogspot.com/2016/07/hololens-cubebouncer-application-part-1.html" target="_blank">CubeBouncer</a> and for floating info screens in my other apps. Basically I want to know a position dead ahead of the user, at a certain maximum distance, or closer by if the user is looking at a physical object that is closer by. Think of an invisible ray coming out of the HoloLens – I want to have a point where it strikes a physical object – and if there is no such thing within a certain maximum distance, I want a point along that ray at a maximum distance.</p><p>I made a little helper class for that, and it’s called LookingDirectionHelpers</p>
<pre style="font-size: 10px;">using HoloToolkit.Unity.InputModule;
using HoloToolkit.Unity.SpatialMapping;
using UnityEngine;

namespace HoloToolkitExtensions.Utilities
{
    public static class LookingDirectionHelpers
    {
        public static Vector3 GetPostionInLookingDirection(float maxDistance = 2, 
            BaseRayStabilizer stabilizer = null )
        {
            RaycastHit hitInfo;
            var headReady = stabilizer != null
                ? stabilizer.StableRay
                : new Ray(Camera.main.transform.position, Camera.main.transform.forward);

            if (SpatialMappingManager.Instance != null &amp;&amp;
                Physics.Raycast(headReady, out hitInfo, maxDistance,<br>                                SpatialMappingManager.Instance.LayerMask))
            {
                return hitInfo.point;
            }

            return CalculatePositionDeadAhead(maxDistance);
        }

        public static Vector3 CalculatePositionDeadAhead(float distance = 2, 
            BaseRayStabilizer stabilizer = null)
        {
            return (stabilizer != null
                       ? stabilizer.StableRay.origin + stabilizer.StableRay.direction
                       : Camera.main.transform.position + Camera.main.transform.forward)
                       .normalized * distance;
        }
    }
}
</pre><p>Although it’s a small thing, it actually does quite a lot. If you call GetPostionInLookingDirection</p><ul><li>It first tries to determine a so-called head ray. This can either come from the stabilizer or be directly calculated from the location and angle of the camera (that is, your head). I would recommend feeding it a stabilizer, as that makes for getting a much more reliable location.</li><li>If it actually finds a hit, it returns that point</li><li>If it does not, it uses CalculatePositionDeadAhead to, well, calculate a position dead ahead. It takes once again either the stabilizer head ray or calculates one from the camera, then normalizes it (i.e. makes it’s length 1) and then multiplies it with the desired distance. This effectively gives a point <em>distance</em> meters right before the user’s eyes.</li></ul><p>This script requires the presence of a SpatialMappingManager prefab, for that’s the only way to find out which Unity layer contains the spatial mesh. If you want to call this script using a stabilizer (and I think you should), the InputManager should be present as well, as that will create a GazeManager singleton, which contains the stabilizer. So you can call this helper class like this:</p><pre style="font-size: 10px;">var pos = LookingDirectionHelpers.GetPostionInLookingDirection(2.0f, GazeManager.Instance.Stabilizer);</pre><p>And that will return you a point at either a Spatial Mesh, or at 2 meters distance from the user.</p><p>Although and the code involved is not very voluminous, I have gone all the way and made and – albeit pretty lame – minimalist demo for it <a href="https://github.com/LocalJoost/LookingDirectionDemo" target="_blank">that you can download here</a>. This is based upon a <a href="https://github.com/Microsoft/HoloToolkit-Unity" target="_blank">HoloToolkit</a> based setup <a href="http://dotnetbyexample.blogspot.com/2017/06/setting-up-hololens-project-with.html" target="_blank">as described here</a>. All it does it, when you move around, is print the location onto the debug log. So this will only work in the Unity editor, on the HoloLens emulator, or on an app running in debug mode on an actual HoloLens – but you won’t see much happening on the device itself, just in debug windows on your screen. </p><p><a href="https://lh3.googleusercontent.com/-osT5e9avZ0A/WVJFVYXPf8I/AAAAAAAAO9U/a6_b4OJV-kgV6aySMZVqWB_ULZw1rCioACHMYCw/s1600-h/image%255B3%255D"><img width="644" height="419" title="image" style="display: inline; background-image: none;" alt="image" src="https://lh3.googleusercontent.com/-JgHMb0S27qY/WVJFV3yJVlI/AAAAAAAAO9Y/iUCpxGL38mk0uN2z8rn-yUAMIG3iTo2fgCHMYCw/image_thumb%255B1%255D?imgmax=800" border="0"></a></p><p>But it shows how it works and can be used, and that is the point. Later in this blog we will see a better application for this.</p>