---
layout: post
title: Using Azure Custom Vision Object Recognition and HoloLens to identify and label
  objects in 3D space
date: '2018-11-24T17:31:00.000+01:00'
author: Joost van Schaik
tags:
- Custom Vision
- HoloLens
- Windows Mixed Reality
- Artificial Intelligence
- Machine Learning
modified_time: '2018-11-25T15:09:32.091+01:00'
thumbnail: https://lh3.googleusercontent.com/-JOkn97qmM4E/W_l8wfwkk4I/AAAAAAAAQc8/x3A2l6cVygUOVTRPEb_d-E3B1gCzDWu2QCHMYCw/s72-c/image_thumb%255B2%255D?imgmax=800
blogger_id: tag:blogger.com,1999:blog-5295746446529817470.post-3236699952919240178
blogger_orig_url: https://dotnetbyexample.blogspot.com/2018/11/using-azure-custom-vision-object.html
---

<h2>Intro</h2><p><a href="https://www.microsoft.com/en-us/hololens" target="_blank">HoloLens</a> is cool, Machine Learning is cool, what's more fun than combine these two great techniques. Very recently you could read <a href="https://blogs.msdn.microsoft.com/appconsult/2018/11/15/23535/" target="_blank">"Back to the future now: Execute your Azure trained Machine Learning models on HoloLens!"</a>&nbsp; on the AppConsult blog, and as early as last May my good friend <a href="https://social.msdn.microsoft.com/profile/Matteo+Pagani" target="_blank">Matteo Pagani</a> wrote on the same blog <a href="https://blogs.msdn.microsoft.com/appconsult/2018/05/23/add-a-bit-of-machine-learning-to-your-windows-application-thanks-to-winml/" target="_blank">about his very first experiments</a> with <a href="https://docs.microsoft.com/en-us/windows/uwp/machine-learning/overview" target="_blank">WindowsML</a> - as the technology to run machine learning models on your Windows ('edge') devices is called. Both of the blog posts use an<em> Image Classification</em> algorithm, which basically tells you whether or not an object is in the image, and what the confidence level of this recognition is. </p><p>And then this happened:</p><p><a href="https://lh3.googleusercontent.com/-YUtxzp5O4w4/W_l8v2H-tzI/AAAAAAAAQc4/MVZCS3MKmaomr_36a3wBCpiYD7gfmAUfQCHMYCw/s1600-h/image%255B4%255D"><img width="300" height="248" title="image" align="left" style="margin: 0px 8px 0px 0px; border: 0px currentcolor; border-image: none; float: left; display: inline; background-image: none;" alt="image" src="https://lh3.googleusercontent.com/-JOkn97qmM4E/W_l8wfwkk4I/AAAAAAAAQc8/x3A2l6cVygUOVTRPEb_d-E3B1gCzDWu2QCHMYCw/image_thumb%255B2%255D?imgmax=800" border="0"></a>"<strong><em>Object Detection</em> finds the location of content within an image</strong>" is the definition that pops up if you hover your mouse over the (i) symbol behind "Project Types". So not only do you get a hit and a confidence level <em>but also the location in the image where the object is</em>.</p><p><em>Now things are getting interesting</em>. I wondered if I could use this technique to detect objects in the picture and <em>then</em> use HoloLens' depth camera to actually guestimate where those object where in 3D space.</p><p><br></p><p><br></p><p><br></p><p>The short answer: yes. It works surprisingly good. </p><p><a href="https://lh3.googleusercontent.com/-Tn1Pr4hoaT0/W_l8xDw79LI/AAAAAAAAQdA/hAa6h0L24eY0EFaCkO9Ks6tYRT5eMYgpwCHMYCw/s1600-h/20181114_131716_HoloLens%255B4%255D"><img width="640" height="360" title="20181114_131716_HoloLens" style="border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" alt="20181114_131716_HoloLens" src="https://lh3.googleusercontent.com/-NhNCRtu9ojM/W_l8xwYxyUI/AAAAAAAAQdE/ZVUiftYKD00ZjGMEYh3PjwNwCk-AOTleACHMYCw/20181114_131716_HoloLens_thumb%255B2%255D?imgmax=800" border="0"></a></p><h2>The global idea</h2><ul><li>User air taps to initiate the process</li><li>The HoloLens takes a quick picture and uploads the picture to the Custom Vision API</li><li>HoloLens gets the recognized areas back</li><li>Calculates the center of each area with a confidence level &lt; 0.7</li><li>'Projects' these centers on a plane 1 m wide and 0.56 high that's 1 meter in front of the Camera (i.e. the user's viewpoint)</li><li>'Shoots' rays from the Camera through the projected center points and checks if and where the strike the Spatial Map</li><li>Places labels on the detected points (if any).</li></ul><h2>Part 1: creating and training the model</h2><p>Matteo already wrote about how simple it actually is to create an empty model in <a href="https://customvision.ai/" target="_blank">CustomVision.ai</a> so I skip that part. Inspired by his article I wanted to recognize airplanes as well, but I opted for <em>model</em> airplanes - much easier to test with than actual airplanes. So I dusted off all the plastic airplane models I had built during my late teens - this was a thing shy adolescent geeks like me sometimes did, back in the Jurassic when I grew up ;) - it helped we did not have spend 4 hours per day on social media ;). But I digress. I took a bunch of pictures of them:</p><p><a href="https://lh3.googleusercontent.com/-CbdUZiteFgQ/W_l8yytBPjI/AAAAAAAAQdI/Hb8tqWsdDwU5YDzJXPuHH_gqtBzY8WuEwCHMYCw/s1600-h/image%255B9%255D"><img width="640" height="351" title="image" style="border: 0px currentcolor; border-image: none; display: inline; background-image: none;" alt="image" src="https://lh3.googleusercontent.com/-9L7c_H47Qqs/W_l8zqXPjTI/AAAAAAAAQdM/Jm9CihUZ8A8F-99NorEmBlldcIYsHf4bACHMYCw/image_thumb%255B5%255D?imgmax=800" border="0"></a></p><p>And then, picture by picture, I had to mark and label the areas which contains the desired objects. This is what is different from training a model for 'mere' object classification: you have to mark <em>every</em> occasion of your desired object.</p><p><a href="https://lh3.googleusercontent.com/-38Quf0edSVQ/W_l80i8T_ZI/AAAAAAAAQdQ/IO_VfKauge8IaDivsHS6uUZPfPJPILLpgCHMYCw/s1600-h/image%255B17%255D"><img width="640" height="425" title="image" style="border: 0px currentcolor; border-image: none; display: inline; background-image: none;" alt="image" src="https://lh3.googleusercontent.com/-zbac6f9PO30/W_l812Zv5LI/AAAAAAAAQdU/0gLjxFW7JmInkGWottm0Z55HKVuZTsqKACHMYCw/image_thumb%255B9%255D?imgmax=800" border="0"></a></p><p>This is very easy to do, it's a bit boring and repetitive, but learning stuff takes sacrifices, and in the end I had quite an ok model. You train in it just the same way as Matteo already wrote about - by hitting big green 'Train'&nbsp; button that's kind of hard to miss on the top right.</p><p>When you are done, you will need two things:</p><ul><li>The Prediction URL</li><li>The Prediction key.</li></ul><p>You can get those by clicking the "Performance" tab on top:</p><p><a href="https://lh3.googleusercontent.com/-tMVn3drZ-AQ/W_l82nWf4vI/AAAAAAAAQdY/5j3oiVVxhWgf_wf64VmYosAsBIxW0nvFACHMYCw/s1600-h/image%255B22%255D"><img width="640" height="51" title="image" style="border: 0px currentcolor; border-image: none; display: inline; background-image: none;" alt="image" src="https://lh3.googleusercontent.com/-OdJxoskH4ZA/W_l83HOpgXI/AAAAAAAAQdc/BRfHrj7ZPgYagnuytndC3fZp4aMVcfUUgCHMYCw/image_thumb%255B12%255D?imgmax=800" border="0"></a></p><p>Then click the "Prediction URL" tab </p><p><a href="https://lh3.googleusercontent.com/-1c7cMyYWPaE/W_l839u6laI/AAAAAAAAQdg/CWnvRtcn7QMnhEU4unHIGkMzJrCiJbg9gCHMYCw/s1600-h/image%255B33%255D"><img width="400" height="40" title="image" style="border: 0px currentcolor; border-image: none; display: inline; background-image: none;" alt="image" src="https://lh3.googleusercontent.com/-UTc4c7FHZsE/W_l84rKy1GI/AAAAAAAAQdk/JF-k2v_IvdM5PlSbwS5jmxT2dW8RNkTpACHMYCw/image_thumb%255B17%255D?imgmax=800" border="0"></a></p><p>And this will make this popup appear with the necessary information</p><p><a href="https://lh3.googleusercontent.com/-UlDk7GKrGUE/W_l85Ac9hqI/AAAAAAAAQdo/fsYy3hSo-HkJvDwKYfczuVIybmH_QKyJwCHMYCw/s1600-h/image%255B38%255D"><img width="300" height="254" title="image" style="border: 0px currentcolor; border-image: none; display: inline; background-image: none;" alt="image" src="https://lh3.googleusercontent.com/-WVtnDJMkxNU/W_l85ma8d2I/AAAAAAAAQds/F5yhuE0f0GcewzBmWsHBDyqwV9r_fwVhwCHMYCw/image_thumb%255B20%255D?imgmax=800" border="0"></a></p><h2>Part 2: Building the HoloLens app to use the model</h2><h3>Overview</h3><p>The app is basically using three main components:</p><ul><li>CameraCapture</li><li>ObjectRecognizer</li><li>ObjectLabeler</li></ul><p>They sit in the Managers object and communicate using the <a href="http://dotnetbyexample.blogspot.com/2017/04/using-messenger-to-communicate-between.html" target="_blank">Messenger</a> that I wrote about earlier.</p><h2>Part 2a: CameraCapture gets a picture - when you air tap</h2><p><a href="https://lh3.googleusercontent.com/-yfVTim0UjJI/W_mCmeZtn1I/AAAAAAAAQeM/BxXpOPps1YMUj2bom4LTIUsSAscAE3NYQCHMYCw/s1600-h/image%255B45%255D"><img width="304" height="288" title="image" align="left" style="margin: 0px 8px 0px 0px; float: left; display: inline; background-image: none;" alt="image" src="https://lh3.googleusercontent.com/-N_PHyTDp65k/W_mCnEUEarI/AAAAAAAAQeQ/Fuf-5UK8mA4HJxodF0htyejLEnQWQ88EwCHMYCw/image_thumb%255B23%255D?imgmax=800" border="0"></a><a href="https://quoteinvestigator.com/2013/03/06/artists-steal/" target="_blank">It's not exactly clear who originally came up with a saying like "great artist steal"</a> but although I don't claim any greatness I do steal. CameraCapture is a slightly adapted version of <a href="https://docs.unity3d.com/Manual/windowsholographic-photocapture.html" target="_blank">this article in the Unity documentation</a>. There are only a few changes. The original always captures the image in the "BRA32" format as this can be used as texture on a plane or quad. Unfortunately that is not a format CustomVision accepts. The app does show the picture it takes before the user's eye if the DebugPane property is set to a game object (in <a href="https://github.com/LocalJoost/ToyAircraftFinder" target="_blank">the demo project</a> it is). Should you not desire this, simply clear the "Debug Pane" field in the "Camera Capture" script in the Unity editor.</p><p><br></p><p><br></p><p>So what you basically see is that CameraCapture takes a picture in a format based upon whether or not the DebugPane is present:</p><pre style="font-size: 12px;"> pixelFormat = _debugPane != null ? CapturePixelFormat.BGRA32 : CapturePixelFormat.JPEG</pre><p>and then either directly copies the captured (JPEG) photo into the photoBuffer, or it shows in on the DebugPane and as BRA32 and converts it to JPEG from there</p><pre style="font-size: 12px;">void OnCapturedPhotoToMemory(PhotoCapture.PhotoCaptureResult result, <br>                             PhotoCaptureFrame photoCaptureFrame)
{
    var photoBuffer = new List&lt;byte&gt;();
    
    if (photoCaptureFrame.pixelFormat == CapturePixelFormat.JPEG)
    {
        photoCaptureFrame.CopyRawImageDataIntoBuffer(photoBuffer);
    }
    else
    {
        photoBuffer = ConvertAndShowOnDebugPane(photoCaptureFrame);
    }

    Messenger.Instance.Broadcast(
        new PhotoCaptureMessage(photoBuffer, _cameraResolution, CopyCameraTransForm()));

    // Deactivate our camera
    _photoCaptureObject.StopPhotoModeAsync(OnStoppedPhotoMode);
}</pre><p>The display and conversion is done this way:</p><pre style="font-size: 12px;">private List&lt;byte&gt; ConvertAndShowOnDebugPane(PhotoCaptureFrame photoCaptureFrame)
{
    var targetTexture = new Texture2D(_cameraResolution.width, 
      _cameraResolution.height);
    photoCaptureFrame.UploadImageDataToTexture(targetTexture);
    Destroy(_debugPane.GetComponent&lt;Renderer&gt;().material.mainTexture);

    _debugPane.GetComponent&lt;Renderer&gt;().material.mainTexture = targetTexture;
    _debugPane.transform.parent.gameObject.SetActive(true);
    return new List&lt;byte&gt;(targetTexture.EncodeToJPG());
}</pre><p>It creates a texture, uploads the buffer into it, destroys the current texture and sets the new texture. Then the object game object is actually being displayed, and then it's used to convert the image to JPEG</p><p>Either way, the result is a JPEG, and the buffer contents are sent on a message, together with the camera resolution and a copy of the Camera's transform. The resolution we need to calculate the height/width ratio of the picture, and the transform we need to retain because in between the picture being taken and the result coming back the user may have moved. Now you can't just send the Camera's transform, when the user moves. So you have to send a 'copy', which is made by this rather crude method, using a temporary empty gameobject:</p><pre style="font-size: 12px;">private Transform CopyCameraTransForm()
{
    var g = new GameObject();
    g.transform.position = CameraCache.Main.transform.position;
    g.transform.rotation = CameraCache.Main.transform.rotation;
    g.transform.localScale = CameraCache.Main.transform.localScale;
    return g.transform;
}</pre><h3>Part 2b: ObjectRecognizer sends it to CustomVision.ai and reads results</h3><p>The ObjectRecognizer is, apart from some song and dance to pick the message apart and start a Coroutine, a fairly simple matter. This part does all the work:</p><pre style="font-size: 12px;">private IEnumerator RecognizeObjectsInternal(IEnumerable&lt;byte&gt; image, 
    Resolution cameraResolution, Transform cameraTransform)
{
    var request = UnityWebRequest.Post(_liveDataUrl, string.Empty);
    request.SetRequestHeader("Prediction-Key", _predictionKey);
    request.SetRequestHeader("Content-Type", "application/octet-stream");
    request.uploadHandler = new UploadHandlerRaw(image.ToArray());
    yield return request.SendWebRequest();
    var text = request.downloadHandler.text;
    var result = JsonConvert.DeserializeObject&lt;CustomVisionResult&gt;(text);
    if (result != null)
    {
        result.Predictions.RemoveAll(p =&gt; p.Probability &lt; 0.7);
        Debug.Log("#Predictions = " + result.Predictions.Count);
        Messenger.Instance.Broadcast(
            new ObjectRecognitionResultMessage(result.Predictions, 
            cameraResolution, cameraTransform));
    }
    else
    {
        Debug.Log("Predictions is null");
    }
}</pre>
<p>You will need to set _liveDataUrl and predictionKey values via the editor, as you could see in the image just below the Part 2a header. This behaviour creates a web request to the prediction URL, adds the prediction key as header, and the right content type. The body content is set to the binary image data using an UploadHandlerRaw. And then the request is sent to CustomVision.ai. The result is then deserialized into a CustomVisionResult object, all the predictions with a probability lower than the 0.7 threshold are removed, and the predications are put back into a message, to be sent to the ObjectLabeler, together once again with the camera's resolution and transform.</p><p>A little note: the CustomVisionResult together with all the classes it uses are in the CustomVisionResult.cs file in <a href="https://github.com/LocalJoost/ToyAircraftFinder" target="_blank">the demo project</a>. This code was <em>generated</em> by first executing executing the SendWebRequest and then copying the raw output of "request.downloadhandler.text" into <a href="https://app.quicktype.io/" target="_blank">QuickType</a>. It's an ideal site to quickly make classes for JSON serialization. </p><p>Interestingly to note here is that Custom Vision returns bounding boxes by giving top,left, width and height - in values that are always between 0 and 1. So if the top/left of your picture sits at (0,0) it's all the way to the top/left of the picture, and (1,1) is a the bottom right of the picture. <em>Regardless of the height/with ratio of your picture</em>. So if your picture is not square (and most cameras don't create square pictures)) you need to know the actual width and height of your picture - that way, you can calculate what pixel coordinates actually correspond to the numbers Custom Vison returns. And that's exactly what the next step does.</p><h3>Part 2c: ObjectLabeler shoots for the Spatial Map and places labels</h3><p>The ObjectLabeler also contains pretty little code as well, although the calculations may need a bit of explanation. The central piece of code is this method:</p><pre style="font-size: 12px;">public virtual void LabelObjects(IList&lt;Prediction&gt; predictions, 
    Resolution cameraResolution, Transform cameraTransform)
{
    ClearLabels();
    var heightFactor = cameraResolution.height / cameraResolution.width;
    var topCorner = cameraTransform.position + cameraTransform.forward -
                    cameraTransform.right / 2f +
                    cameraTransform.up * heightFactor / 2f;
    foreach (var prediction in predictions)
    {
        var center = prediction.GetCenter();
        var recognizedPos = topCorner + cameraTransform.right * center.x -
                            cameraTransform.up * center.y * heightFactor;

        var labelPos = DoRaycastOnSpatialMap(cameraTransform, recognizedPos);
        if (labelPos != null)
        {
            _createdObjects.Add(CreateLabel(_labelText, labelPos.Value));
        }
    }

    if (_debugObject != null)
    {
         _debugObject.SetActive(false);
    }

    Destroy(cameraTransform.gameObject);
}</pre><p>First, we clear any labels that might have been created in a previous run. Then we calculate the height/width ratio of the picture (this is 2048x1152, so heightFactor will always be 0.5625, but why hard code something that can be calculated). Then comes the first interesting part. Remember that I wrote we are projecting the picture on a plane 1 meter before the user. We do this because the picture then looks pretty much live sized. So we need to go forward 1 meter from the camera position:</p><p><strong>cameraTransform.position + cameraTransform.forward.normalized</strong> </p><p>But then we end up in the <em>center</em> of the plane. We need to get to the top <em>left</em> corner as a starting point. So we go half a meter to the left (actually, -1 * right, which amounts to left), then half the height factor up. </p><p><strong>cameraTransform.up * heightFactor / 2f</strong></p><p>In image, like this:</p><p><a href="https://lh3.googleusercontent.com/-CBuV8MbPiXA/W_qdEAQKuBI/AAAAAAAAQgY/L2CiV92lk7IeYTYMcYDaSIyFUR6N3eoCwCHMYCw/s1600-h/image%255B5%255D"><img width="300" height="266" title="image" style="border: 0px currentcolor; border-image: none; display: inline; background-image: none;" alt="image" src="https://lh3.googleusercontent.com/-IWX9nFspCoo/W_qdEyPPP9I/AAAAAAAAQgc/OgFUCK9A1LwP_aN7loWXVd6A4XY338h_ACHMYCw/image_thumb%255B2%255D?imgmax=800" border="0"></a></p><p>Once we are there, we calculate the center of the prediction using a very simple extension method:</p><pre style="font-size: 12px;">public static Vector2 GetCenter(this Prediction p)
{
    return new Vector2((float) (p.BoundingBox.Left + (0.5 * p.BoundingBox.Width)),
        (float) (p.BoundingBox.Top + (0.5 * p.BoundingBox.Height)));
}</pre><p>To find the actual location <em>on</em> the image, we basically use the same trick again in reverse: first move to the <em><u>right</u></em> the amount the x is from the top corner</p><p><strong>var recognizedPos = topCorner + cameraTransform.right * center.x</strong></p><p>And then a bit <em>down</em> again (actually , -up) using the y value scaled for height.</p><p><strong>-cameraTransform.up * center.y * heightFactor;</strong></p><p>Then we simply do a ray cast to the spatial map from the camera position through the location we calculated, basically shooting 'through' the picture for the <em>real</em> object.</p><pre>private Vector3? DoRaycastOnSpatialMap(Transform cameraTransform, 
                                       Vector3 recognitionCenterPos)
{
    RaycastHit hitInfo;

    if (SpatialMappingManager.Instance != null &amp;&amp; 
        Physics.Raycast(cameraTransform.position, 
                       (recognitionCenterPos - cameraTransform.position), 
            out hitInfo, 10, SpatialMappingManager.Instance.LayerMask))
    {
        return hitInfo.point;
    }
    return null;
}</pre><p>and create the label at the right spot. I copied the code for creating the label <a href="http://dotnetbyexample.blogspot.com/2018/11/responding-to-focus-and-showing-data.html" target="_blank">from two posts ago</a>, so I will skip repeating that here.</p><p>There is little bit I want to repeat here</p><pre style="font-size: 12px;">if (_debugObject != null)
{
     _debugObject.SetActive(false);
}

Destroy(cameraTransform.gameObject);
</pre><p>If the debug object is set (that is to say, the plane showing the photo HoloLens takes to upload) it will be turned off here otherwise it obscures the actual labels. But more importantly is the last line: I created the copy of the camera's transform using a temporary game object. As the user keeps on shooting pictures those will add up and clutter the scene. So after the work is done, I clean it up.</p><h2>And the result...</h2><p>The annoying thing is, al always, I can't show you a video the whole process as any video recording stops as soon as the app takes a picture. So the only think I can show you is this kind of doctored video - I restarted video immediately after taking the picture, but I miss the part of where the actual picture is floating in front of the user. This is how it looks like, though, if you disable the debug pane from the Camera Capture script:</p><iframe width="650" height="365" src="https://www.youtube.com/embed/DmPhKpKSne8" frameborder="0" allowfullscreen="" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe><h2>Lessons learned</h2><ul><li>There is a reason why Microsoft says you need at least 50 pictures for a bit reliable recognition. I took about 35 pictures of about 10 different models of airplanes. I think I should have take more like 500 pictures (50 of every type of model airplanes) and then things would have gone a lot better. Nevertheless, it already works pretty well</li><li>If the camera you use is pretty so-so (exhibit A: the HoloLens built-in video camera) it does not exactly help if your <em>training</em> pictures are made with a high end DSLR, which shoots in great detail, handles adverse lighting conditions superbly, and never, ever has a blurry picture. </li></ul><h2>Conclusion</h2><p>Three simple objects to call a remote Custom Vision Object Recognition Machine Learning model and translate its result into a 3D label. Basically a Vuforia-like application but then using 'artificial intelligence'&nbsp; I love the way how Microsoft are taking the very thing they really excel in - democratizing and commoditizing complex technologies into usable tools - to the Machine Learning space.</p><p>The app I made is quite primitive, and it's also has a noticeable 'thinking moment' - since the model lives in the cloud and has to be accessed via a HTTP call. This is because the model is not a 'compact' model, therefore it's not downloadable and it's can't run on WindowsML. Wel will see what the future has in store for these kinds of models. But the app shows what's possible with these kinds of technologies, and it makes the prospect of a <a href="https://www.microsoft.com/en-us/research/blog/second-version-hololens-hpu-will-incorporate-ai-coprocessor-implementing-dnns/" target="_blank">next version of HoloLens having an AI coprocessor</a> all the more exiting!</p><p><a href="https://github.com/LocalJoost/ToyAircraftFinder" target="_blank">Demo project</a> - without the model, unfortunately - can be downloaded here.&nbsp; </p>