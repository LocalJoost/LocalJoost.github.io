---
layout: post
title: A HoloLens airplane tracker 4–Reading data and positioning airplanes
date: '2016-10-15T14:05:00.002+02:00'
author: Joost van Schaik
tags:
- UWP
- HoloLens
- Unity3D
modified_time: '2016-10-15T14:12:55.631+02:00'
thumbnail: http://2.bp.blogspot.com/-18VdaBXv2sM/T9GzlEMuu3I/AAAAAAAAAEE/SCtfkqZlEYs/s72-c/roll+pitch+yaw.png
blogger_id: tag:blogger.com,1999:blog-5295746446529817470.post-4004494303119930123
blogger_orig_url: https://dotnetbyexample.blogspot.com/2016/10/a-hololens-airplane-tracker-4reading.html
---

<h2>Time to rock and roll</h2> <p>All right my friends, it’s time to show the heart of the matter – how to read data from an Azure Mobile App Services data service and make the airplanes appear in the right places. </p> <h2>Adding the JSON data object scripts</h2> <p>As the projects are partially regenerated, and have a total different .NET baseline, I have not found a good way to share classes as binaries between full .NET code and Unity without getting in all kinds of trouble, so I choose the easy way out: I took</p> <ul> <li>TrackType.cs  <li>Coordinate.cs  <li>Flight.cs</li></ul> <p>from the FlightDataService\DataObjects, moved them the App/Scripts/DataObjects folder in the Unity project. Then of course the service does not compile anymore, but I added the moved file <em>as link</em>. Then at least we have once source of truth as far as these classes are concerned.</p> <p>Then we need a simple class to hold a list of flights with a timestamp (add that to the DataObjects folder as well):</p><pre>using System;
using System.Collections.Generic;

namespace FlightDataService.DataObjects
{
  public class FlightSet
  {
    public FlightSet()
    {
    }

    public FlightSet(List&lt;Flight&gt; flights)
    {
      Flights = flights;
      TimeStamp = DateTimeOffset.Now;
    }
    public DateTimeOffset TimeStamp { get; set; }

    public List&lt;Flight&gt; Flights { get; set; }
  }
}</pre>
<h2>Adding a DataService to read data</h2>
<p>I opted to add the DataService as a Singleton that can be accessed in the app. But we have a bit of an issue here -&nbsp; Unity runs on Mono, e.g. .NET 3.something, and does not have things like packages for reading App services, or support async and Tasks and stuff. But remember – a HoloLens app is a two stage rocket. Unity does not generate an app for the HoloLens, but <em>an UWP project</em>, and that UWP project <em>can</em> use all the goodness from all the latest stuff. Meet the simple way to close the gap - my new friend UNITY_UWP.</p><pre>using System;
using System.Collections.Generic;
using FlightDataService.DataObjects;
using HoloToolkit.Unity;
#if UNITY_UWP
using Microsoft.WindowsAzure.MobileServices;
using System.Net.Http;
using System.Threading.Tasks;
#endif

public class DataService : Singleton&lt;DataService&gt;
{
  public string DataUrl = "http://yourflightdataservice.azurewebsites.net/";

#if UNITY_UWP
    private MobileServiceClient _client;
#endif

  public DataService()
  {
#if UNITY_UWP
    _client = new MobileServiceClient(new Uri(DataUrl));
#endif
  }

#if UNITY_UWP
  public async Task&lt;List&lt;Flight&gt;&gt; GetFlights()
  {
    var result = await _client.InvokeApiAsync&lt;List&lt;Flight&gt;&gt;(
	                "FlightData", HttpMethod.Get, null);
    return result;
  }
#endif
}
</pre>
<p>Code between #if UNITY_UWP – #endif blocks is invisible to Unity – <em>but will be accessible in the UWP HoloLens app that is generated by Unity</em>. You will see Unity swallows it – no problems at all. There is only this tiny thing – you cannot add NuGet packages to Unity. So we have to do that <em>in the UWP app</em>, in Visual Studio. But… the UWP app is generated from Unity by File/Build and overwritten. The trick is to know not the whole app is overwritten, but only part of it. What I did was the following:</p>
<p><a href="http://www.schaikweb.net/dotnetbyexample/A-HoloLens-airplane-tracker-4Reading-dat_12138/image.png"><img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; float: right; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="image" src="http://www.schaikweb.net/dotnetbyexample/A-HoloLens-airplane-tracker-4Reading-dat_12138/image_thumb.png" width="244" align="right" height="174"></a></p>
<ul>
<li>Generate the app in a subfolder “App” of the Unity project. This should be &lt;your_root&gt;\HoloATC_Demo\AMS HoloATC Demo\App 
<li>Open the solution in HoloATC_Demo\AMS HoloATC Demo\App (<em><strong><u>not </u></strong>the one in HoloATC_Demo\AMS HoloATC Demo</em>) 
<li>Go to the project Assembly-Csharp 
<li>Add the NuGet Package Microsoft.Azure.Mobile.Client 
<li>Find the project.json file that belong to this project. You will find it’s not under AMS HoloATC Demo\App at all, but in AMS HoloATC Demo\UWP\Assembly-CSharp\project.json 
<li>This is the only file that has been changed with respect to the generated code. <em>You will have to add this to source control</em>. Even if Git claims it’s an ignored file. 
<li>After that – if you checkout the source in a different location or on a different machine, you will only have to regenerate the solution in the right place (the App folder), and revert this specific file. You will need to do this, or else the UWP app won’t compile.</li></ul>
<h2>Adding the AircraftLoader to create and update aircraft</h2>
<p>I have created one class that is actually responsible for actually getting the aircraft data from the DataService – and one that is responsible for creating, updating and deleting aircraft. The updating – moving to a new position – is handled by the Aircraft<em>Controller</em> – basically all the AircraftLoader says to the airplane is ‘here is new data for you – handle it’ </p>
<p>Remember – it’s always best to start in Unity. So create an AircraftLoader and an AircraftController script in Assets/App/Scripts. Then proceed to double-click on AircraftLoader. This will open a Visual Studio instance. Be aware – this is not the project your will be running. This is the other solution, the one that is in the project root – I call this the ‘Edit’ solution. First, we are going to make sure the “usins” of the class are properly organized – that is, in a way that doesn’t make Unity go belly-up:</p><pre>using System;
using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using FlightServices.Data;
#if UNITY_UWP
using System.Threading.Tasks;
using Windows.Web.Http;
using Newtonsoft.Json;
#endif</pre>
<p>Then we are going to add a whole lot of fields. And yes, some are public. These are things that can be set from the Unity editor. I have talked about that before.</p><pre>public GameObject Aircraft;

public string TopLevelName = "HologramCollection";

private Dictionary&lt;string, GameObject&gt; _aircrafts;

private readonly TimeSpan _waitTime = TimeSpan.FromSeconds(5);

private DateTimeOffset _lastUpdate = DateTimeOffset.MinValue;

private Queue&lt;FlightSet&gt; _receivedData;

private GameObject _topLevelObject;</pre>
<ul>
<li>The Aircraft GameObject field will be used to drag our AircraftHolder onto – so this behaviour knows which game object to create 
<li>TopLevelName is the name of the parent object to which all the aircraft are added to. This&nbsp; “HologramCollection” by default 
<li>_aircrafts is a dictionary of aircraft game objects with their id as key, so we can update/delete existing aircraft game objects based upon the data coming in 
<li>waitTime – minimal time to load new data 
<li>_lastUpdate – the time the last update of aircraft was completed 
<li>_receivedData – a queue with data coming from the service. I use this pattern all the time. I queue up data from the service, then read it in the Update method that Unity calls automatically 60 times a second. Don’t ever try to update game objects from .NET callback methods or events – you might regret it, or just get plain crashes – kind of like happens in UWP XAML apps, where you need the Dispatcher to take care of that
<li>_topLevelObject – to store the game object with the TopLevelName in it. I have been told the method I use to find an object by name is quite heavy on performance – so better do it once and retain the result, right.</li></ul>
<p>The Start method simply initializes some stuff:</p><pre>void Start()
{
  _aircrafts = new Dictionary&lt;string, GameObject&gt;();
  _receivedData = new Queue&lt;FlightSet&gt;();
  _topLevelObject = GameObject.Find(TopLevelName);
}</pre>
<p>And then there’s this little method – that is used as callback for the DataService’s GetFlight method:</p><pre>#if UNITY_UWP

  private void ProcessData(Task&lt;List&lt;Flight&gt;&gt; flightData)
  {
    if (flightData.IsCompleted &amp;&amp; !flightData.IsFaulted)
    {
      var set = new FlightSet(flightData.Result);
      _receivedData.Enqueue(set);
    }
  }
#endif</pre>
<p>In short - when the data received and it is ok, just add it to the queue of received data. And then let Update handle it. As a matter of fact – like this:</p><pre>private bool _isUpdating;
void Update()
{
  if ((_lastUpdate - DateTimeOffset.Now).Duration() &gt; _waitTime)
  {
    _lastUpdate = DateTimeOffset.Now;
#if UNITY_UWP
    DataService.Instance.GetFlights().ContinueWith(ProcessData);
#endif
  }
  if (!_isUpdating)
  {
    _isUpdating = true;
    if (_receivedData.Any())
    {
      var set = _receivedData.Dequeue();
      var flightIds = set.Flights.Select(p =&gt; p.Id).ToList();

      var aircraftToDelete = 
        _aircrafts.Keys.Where(p =&gt; !flightIds.Contains(p)).ToList();
      DeleteAircraft(aircraftToDelete);

      var keysToUpdate = _aircrafts.Keys.Where(p =&gt; flightIds.Contains(p));
      var aircraftToUpdate = 
        set.Flights.Where(p =&gt; keysToUpdate.Contains(p.Id)).ToList();
      UpdateAircraft(aircraftToUpdate);

      var aircraftToAdd = 
        set.Flights.Where(p =&gt; !_aircrafts.Keys.Contains(p.Id)).ToList();
      CreateAircraft(aircraftToAdd);
    }

    _isUpdating = false;
  }
}</pre>
<p>First it finds out if it’s necessary to download new data, but downloading and adding happens asynchronously. Then, if there’s any data in the queue, it first makes a list of all the id’s in the newly received flights.</p>
<ul>
<li>Aircrafts that are in the aircraft game object dictionary (with the flight id as key) but are no longer in the list of flights, can be deleted (they have landed or moved out of Dutch airspace) 
<li>Aircraft that appear in that dictionary <em>and</em> in the list of flights need to be updated – possibly moved to a new position 
<li>Aircraft that do <em>not</em> have an entry in the game object dictionary are new, and need to be created. </li></ul>
<p>It’s not that hard, see ;). The methods for creating, updating and deleting aircrafts are not that hard either.</p><pre>private void CreateAircraft(IEnumerable&lt;Flight&gt; flights)
{
  foreach (var flight in flights)
  {
    var aircraft = Instantiate(Aircraft);
    aircraft.transform.parent = _topLevelObject.transform;
    aircraft.transform.localScale = new Vector3(0f, 0f, 0f);
    SetNewFlightData(aircraft, flight);
    _aircrafts.Add(flight.Id, aircraft);
  }
}

private void UpdateAircraft(IEnumerable<flight> flights)
{
  foreach (var flight in flights)
  {
    if (_aircrafts.ContainsKey(flight.Id))
    {
      var aircraft = _aircrafts[flight.Id];
      SetNewFlightData(aircraft, flight);
    }
  }
}

private void DeleteAircraft(IEnumerable&lt;string&gt; keys)
{
  foreach (var key in keys)
  {
    var aircraft = _aircrafts[key];
    Destroy(aircraft);
    _aircrafts.Remove(key);
  }
}</pre>
<p>The CreateAircraft is the most interesting – it instantiates the aircraft game object, makes the HoloGramCollection it’s parent, passes the actual flight data to the object, and adds it to the dictionary of aircraft game objects using the flight id as the key. Oh, and it also sets the scale to 0, making the plane effectively invisible. This is because, without setting a location on instantiation, the aircraft will appear on 0,0,0 before – where in future episodes we will place the center of Schiphol, very near the tower, and that’s not a place where aircraft belong. </p>
<p>UpdateAircraft just sends flight data to the game object, and DeleteAircraft – well, deletes it. There is only this matter of SetNewFlightData: </p><pre>private void SetNewFlightData(GameObject aircraft, Flight flight)
{
  var controller = aircraft.GetComponent&lt;AircraftController&gt;();
  if(controller != null)
  {
    //controller.SetNewFlightData(flight);
  }
}</pre>
<p>But that has the actual method that moves the flight data to the AircraftController commented out, because that does not even <em>exist</em>. What is worse, the Aircraft does not even have to component. So let’s head over back to the Unity Editor.</p>
<h2>Wiring up some stuff in Unity </h2>
<p>First of all, we drag the DataService and AircraftLoader Script from the App/Scripts folder on top of the HologramCollection’s inspector page. Then we drag AircraftHolder prefab from App/Prefabs on top of the AircraftLoader’s “Aircraft” property. Net result should be this:</p>
<p><a href="http://www.schaikweb.net/dotnetbyexample/A-HoloLens-airplane-tracker-4Reading-dat_A318/image.png"><img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="image" src="http://www.schaikweb.net/dotnetbyexample/A-HoloLens-airplane-tracker-4Reading-dat_A318/image_thumb.png" width="354" height="240"></a></p>
<p><em>Please make sure the Data Url property of the Data Service indeed points to the place where your data service <a href="http://localjoost.github.io/2016/10/05/a-hololens-airplane-tracker-1.html" target="_blank">as created in the first post</a> is published.</em></p>
<p>Then go to the App/Prefabs folder, open the AircraftHolder prefab itself, and drag the (still default) AircraftController on top of the AircraftHolder’s inspector page.</p>
<p><a href="http://www.schaikweb.net/dotnetbyexample/A-HoloLens-airplane-tracker-4Reading-dat_A318/image_3.png"><img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="image" src="http://www.schaikweb.net/dotnetbyexample/A-HoloLens-airplane-tracker-4Reading-dat_A318/image_thumb_3.png" width="354" height="178"></a></p>
<p>Save the scene, then rebuild the app with File/Build settings etc. Go back to Visual Studio once the building is finished.</p>
<h2>Creating the AircraftController</h2>
<p>Having programmed OO since the start of this century, I tend to put control where I logically think it belongs, so rather than programming the ‘flight logic’ into a class that loads and translates data too (the AircraftLoader) I opted for putting it into a separate class that would be part of the game object. I tend to conceptualize these combined game objects and components as OO objects - although that is not completely right, it helps me think about it. The start is simple enough</p><pre>public class AircraftController : MonoBehaviour
{
  private Flight _flightData;
  private float? _speed;
  private float? _heading;
  private TextMesh _text;
  private bool _initComplete;
  private bool _firstMove;

  void Start()
  {
    _text = transform.GetComponentInChildren&lt;TextMesh&gt;();
    _initComplete = true;
  }
}</pre>
<p>A few private fields to retain some data. </p>
<ul>
<li>_flightData just keeps the last provide flight data available 
<li>_speed and _heading keep the last speed and heading. The stream of data sometimes misses a beat and provides no speed and/or heading – I prefer then to display the latest data, in stead of heaving the aircraft suddenly rotate to the North (heading 0) and back again when the next set of data is correct again 
<li>_text keeps a reference to the text mesh so I don’t have to look it up every update - potentially 60 times a second 
<li>the _initComplete boolean is a trick I use regularly to prevent other routines using variables like _text before the are initialized. Remember, the Update loop is called independently of what you do. It may look a bit overdone now with only one initialization statement, but believe me – there will be more.</li></ul>
<p>Well then, finally the infamous SetNewFlightData method</p><pre>public void SetNewFlightData(Flight newFlightData)
{
  if(_initComplete)
  {
    var move = _flightData == null ||
               !_flightData.Location.LocationEquals(
                   newFlightData.Location);
    _flightData = newFlightData;

    ExtractSpeedAndHeading();
    if (move)
    {
      SetLocationOrientation();
    }
    else
    {
      SetNewFlightText();
    }
  }
}</pre>
<p>I like to write the code at high level as almost self-explanatory. First we determine if the aircraft needs to be moved, then we ingest the data, and extract speed and heading. Then, when the aircraft needs to be moved, change it’s location, if not, just update the label. The ExtractSpeedAndHeading is pretty straightforward. There is only the thing with heading - that sometimes comes in a negative value, and although Unity3D has no problem with that in positioning the aircraft, I think it looks ugly in the label. So I make sure it's always positive.</p><pre>private void ExtractSpeedAndHeading()
{
  if (_flightData.Heading != null)
  {
    _heading = (float)_flightData.Heading;
  }
  if (_heading &lt; 0)
  {
    _heading += 360;
  }
  if (_flightData.Speed != null)
  {
    _speed = (float)_flightData.Speed;
  }
}</pre>
<p>SetFlightText is also rather trivial </p><pre>private void SetNewFlightText()
{
  var speedText = 
    _speed != null ? string.Format("{0}km/h", _speed) : string.Empty;

    var headingText =
      _heading != null ? string.Format("{0}⁰", _heading) : string.Empty;

    var text = string.Format("{0} {1} {2}m {3} {4}", _flightData.FlightNr,
      _flightData.Aircraft, _flightData.Location.Alt, speedText, 
      headingText).Trim();
  _text.text = text;
}</pre>
<p>Just some clever formatting to prevent empty postfixes like km/h and degrees in the label. By the way – stick to ye olde string.Format and don’t be tempted to use C# 6 string interpolation <a href="http://localjoost.github.io/2016/07/02/gotchathe-associated-script-could-not.html" target="_blank">or you will be sorry</a> (unless you put it between “#if UNITY_UWP – #endif). Anyway, on to the next routine, that actually does all the aircraft manipulation:</p><pre>private void SetLocationOrientation()
{
  SetNewFlightText();

  transform.localPosition = GetFlightLocation();
  if (_flightData.Heading != null)
  {
    transform.localEulerAngles = GetNewRotation();
  }
  if (!_firstMove)
  {
    transform.localScale = new Vector3(0.0015f, 0.0015f, 0.0015f);
    _firstMove = true;
  }
}</pre>
<p>It sets the text too, then set’s the location based on the flight’s location, and set rotation based upon the heading of the aircraft <em>and</em> whether it’s going up or down. Notice I use <em>local</em> position, heading, and scale. This means all those things are <em>relative</em> to the position, rotation and scale <em>of the containing GameObject</em> – HologramCollection. This has the advantage that I can move, rotate and scale the containing object and <em>in one go everything that is in it follows suit</em>. So you don’t have to do all calculations for that – Unity takes care of that form me. I don’t use it in this app just yet, but the actual app already has some experimental code to do that (although that code is not yet in the store version).</p>
<p>Also, note the fact the airplane gets it’s size here (when it’s created it’s 0,0,0). I have the feeling the model is actually a 1:1 scale representation of the actual aircraft – the first time I saw it with the HoloLens I could not find it at first, then turned around and had a “<a href="https://en.wikipedia.org/wiki/Falling_from_the_Sky:_Flight_174" target="_blank">Glimly Glider</a> experience” - a giant aircraft silently swooping down on me from what looked only 10-15 meters. I decide to scale it down to 0.0015 of it’s original size so it appears to be about 10-15cm in a HoloLens – a size more beneficial for getting an good overview, not to mention the blood pressure and heart rate of the average user ;).</p>
<p>Next up are these two routines:</p><pre>private Vector3 GetFlightLocation()
{
  return GetLocalCoordinates(_flightData.Location);
}

private Vector3 GetLocalCoordinates(Coordinate c)
{
  return new Vector3((float)c.X / 15000,
    c.Alt != null ? (float)c.Alt / 2000.0f : 0f,
    (float)c.Y / 15000);
}</pre>
<p>I already discussed the how and why of scaling the down coordinates 15000 times in horizontal direction and 2000 times in vertical direction in a <a href="http://localjoost.github.io/2016/09/28/converting-latlon-coordinates-to-local.html" target="_blank">recent blog post about converting lat/lon/alt coordinates into the Unity3D X/Y/Z system</a>, so I am not going through that again, because the next part is a lot more interesting. First I will show the last method, GetVerticalAngle</p><pre>private float GetVerticalAngle()
{
  var tracksize = _flightData.Track.Count;
  if (tracksize &gt; 2)
  {
    var pLast = _flightData.Track[tracksize - 1];
    var pSecondLast = _flightData.Track[tracksize - 3];
    var delta = pLast.Alt - pSecondLast.Alt;
    if (Math.Abs(delta.Value) &gt; 2.5f)
    {
      return delta &lt; 0 ? 10 : -20;
    }
  }
  return 0;
}</pre>
<p>I found that the data, although it provides information about whether the aircraft is actually ascending or descending, that data is not always correct. So I decided to calculate that myself, based upon the difference between the current location and an older location. Now since an aircraft usually descends a lot slower than it takes off (which is very fortunate for the passenger’s – or at least my – peace of mind) this method basically returns –20 when the aircraft is going up, and 10 when it’s going down. And then we get some beautiful Unity3D math again – or more accurately, methods that <em>prevent</em> you from having to use all kinds of advanced 3D math: </p><pre>private Vector3 GetNewRotation()
{
  var heading = _heading ?? 0;
  var rotation = Quaternion.AngleAxis(heading, Vector3.up).eulerAngles +
      Quaternion.AngleAxis(GetVerticalAngle(), Vector3.right).eulerAngles;
  return rotation;
}</pre>
<p><img style="float: right; display: inline" src="http://2.bp.blogspot.com/-18VdaBXv2sM/T9GzlEMuu3I/AAAAAAAAAEE/SCtfkqZlEYs/s1600/roll+pitch+yaw.png" width="227" align="right" height="179">Try to picture in your mind how this works:</p>
<ul>
<li>For the <em>heading</em> we have to rotate around the axis that is going <em>up</em> (and down, too) from the center of the aircraft – this what they call <em>yaw</em> in aviation 
<li>For the vertical angle – that makes it look whether the aircraft is going up or down – we have to rotate around the axis that goes to the <em>right </em>(and left – so basically over the wings) from the center of the aircraft. In aviation, this is called <em>pitch</em>&nbsp;</li></ul>
<p>You use summarize Quaternion.AngleAxis(angle, Vector3.&lt;the axis you desire&gt;).eulerAngles over multiple axes to get the combined rotation of an object and assign that in one go. Hence you see in SetLocationOrientation() the statement "transform.localEulerAngles = GetNewRotation();"</p>
<h2>The final things</h2>
<p>Go to <em><strong>AircraftLoader</strong></em> 's SetNewFlightData and uncomment the line <pre> //controller.SetNewFlightData(flight);   </pre>
<p>Because we have implemented that in the previous section. Then there’s is the method LocationEquals in Coordinate, that we used in AircraftController but that was not implemented yet ;)</p><pre>public bool LocationEquals(Coordinate other)
{
  if (other == null) return false;
  return (X == other.X &amp;&amp; Y == other.Y &amp;&amp; Alt != null &amp;&amp;
          other.Alt != null &amp;&amp;
          Alt.Value == other.Alt.Value);
}</pre>
<p>And if you run this in a HoloLens or the Emulator, you will see aircraft!</p>
<p><a href="http://www.schaikweb.net/dotnetbyexample/A-HoloLens-airplane-tracker-4Reading-dat_12138/image_3.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="http://www.schaikweb.net/dotnetbyexample/A-HoloLens-airplane-tracker-4Reading-dat_12138/image_thumb_3.png" width="634" height="358"></a></p>
<p>You will notice they won't move through the air but jump from position to position. They also don't show their track, there is no Schiphol Airport map, no ATC tower, no church, no gaze cursor - and you cannot select anything yet - but that is because this post is long enough as it is. The base is here. 3D visualization of a JSON stream. What is left, is basically making things more slick :) </p>
<h2>Conclusion</h2>
<p>In hindsight I might better have splitted this episode in two blog post still, but I hope you have made it to the end. I feel this blog post is the heart of the matter – reading a data stream and turning it into a 3D model – making ‘dry records’ come to life, almost literally. I also showed you some key concepts about positioning and rotating stuff in 3D. </p>
<p>As usual, the code is <a href="https://github.com/LocalJoost/HoloATC_Demo/tree/Blog4" target="_blank">here on GitHub.</a></p>