---
layout: post
title: Migrating to MRTK2 - configuring, understanding and using Windows Mixed Reality
  controllers
date: '2020-04-24T13:45:00.000+02:00'
orgauthor: Joost van Schaik
tags:
- HoloLens
- Windows Mixed Reality
- MRTK2
- Unity3D
- HoloLens2
modified_time: '2020-04-24T16:50:48.627+02:00'
blogger_id: tag:blogger.com,1999:blog-5295746446529817470.post-5433739822650921996
blogger_orig_url: https://dotnetbyexample.blogspot.com/2020/04/migrating-to-mrtk2-configuring.html
---

<h2>Intro</h2><p><img align="right" style="margin: 0px 0px 0px 14px; border: 0px currentcolor; border-image: none; float: right; display: inline; background-image: none;" src="https://www.schaikweb.net/blog/20200418/controllers.jpg" border="0">Although the focus for <a href="https://github.com/Microsoft/MixedRealityToolkit-Unity" target="_blank">Mixed Reality Toolkit</a> 2 now understandably is on Microsoft's big <a href="https://www.microsoft.com/en-us/windows/windows-mixed-reality" target="_blank">Mixed Reality</a> business player - <a href="https://www.microsoft.com/en-us/hololens" target="_blank">HoloLens</a> 2 - it's still perfectly doable - and viable, IMHO - to develop Windows <a href="https://www.microsoft.com/en-us/store/collections/MR-All-ImmersiveContent" target="_blank">Mixed Reality apps</a> for WMR immersive headsets. Case in point: most of the downloads I get for my three Mixed Reality apps in the store come from people using immersive headsets - which is actually not that strange as immersive headsets are readily available for individuals whereas HoloLens (either 1 or 2) is not - and they cost 10-15% of an actual HoloLens to boot.</p><p>And the fun thing is, if you do this correctly, you can even make apps that run on both - with only minor device specific code. Using MRTK2, though, there are some minor problems to overcome:</p><ol><li>The standard MRTK2 configuration allows for only limited use of all the controller's options</li><li>There are no samples - or at least none I could find - that easily shows how actually extend the configurations to leverage the controller's full potential</li><li>Ditto for samples on how to intercept the events and use those from code.</li></ol><p>I intend to fix all of the above in this article. Once and for all ;)</p><h2>Configuration</h2><p>If you have worked a bit with the MRTK2 before, you know what's going to follow: cloning profiles, cloning profiles and more cloning profiles. We are going some four levels deep. Don't shoot the messenger ;)</p><p>Assuming you start with a blank Unity app with the MRTK2 imported, first step is of course to clone the Default profile - or whatever profile you wish to start with, by clicking Copy &amp; customize.</p><p><img width="500" height="196" style="border: 0px currentcolor; border-image: none; background-image: none;" src="https://www.schaikweb.net/blog/20200418/1_copydefaultprofile.png" border="0"></p><p>While you are at it, turn off the diagnostics </p><p><img width="500" height="164" style="border: 0px currentcolor; border-image: none; background-image: none;" src="https://www.schaikweb.net/blog/20200418/1a_diagnostics.png" border="0"></p><p>Next step is to clone the Input System Profile. You might need to drag the inspector a bit wider or you won't see the Clone button</p><p><img width="500" height="251" style="border: 0px currentcolor; border-image: none; background-image: none;" src="https://www.schaikweb.net/blog/20200418/2_cloneinput.png" border="0"></p><p>Step 3 is to clone the Controller Mapping Profile:</p><p><img width="500" height="539" style="border: 0px currentcolor; border-image: none; background-image: none;" src="https://www.schaikweb.net/blog/20200418/3_clonecontrollers.png" border="0"></p><p>Expand the "Controller Definitions" section. If you then select Windows Mixed Reality Left Hand Controller, you will notice a lot of events are filled in for the various controls - but also that a couple are not:</p><p><img width="500" height="331" style="border: 0px currentcolor; border-image: none; background-image: none;" src="https://www.schaikweb.net/blog/20200418/4_controllernotselectable.png" border="0"></p><p>You can select something, but it's not applicable or already assigned to something else. The missing events are:</p><ul><li>Touchpad Press</li><li>Touchpad Position</li><li>Touchpad Touch</li><li>Trigger Touch</li><li>Thumbstick Press</li></ul><p>So we have to <em>add</em> these events. To achieve this, we have to do one final clone: the Default Input Actions Profile.</p><p><img width="500" height="150" style="border: 0px currentcolor; border-image: none; background-image: none;" src="https://www.schaikweb.net/blog/20200418/5_cloneinputactions.png" border="0"></p><p>And then you simply can add the five missing events (or input actions, as they are called in MRKT2 lingo). </p><p><img width="500" height="186" style="border: 0px currentcolor; border-image: none; background-image: none;" src="https://www.schaikweb.net/blog/20200418/6_addinputactions.png" border="0"></p><p>Mind to select "Digital" for all new actions <em>except for Touchpad position</em>. Make that a "Dual Axis". That last one will be explained later.</p><p>Now you can once again go back to Input/Controller/Input Mappings settings, and, assign the proper (new) events to the controller buttons. Don't forget to do this for both the right and the left hand controller.</p><p><img width="500" height="333" style="border: 0px currentcolor; border-image: none; background-image: none;" src="https://www.schaikweb.net/blog/20200418/7_assignactions.png" border="0"></p><p>And now <em>finally </em>there are events attached to all the buttons to the controllers. Now it's time to show how to trap them.</p><h2>Understanding and using the events</h2><p>The important thing to understand is that there are different <em>kind</em> of events, that all need to be trapped in a specific way. When I showed you to add the event types, all but one of them were <em>digital</em> types. Only one was "<em>Dual Axis</em>". There actually are a lot of different types of events:</p><p><img width="500" height="256" style="border: 0px currentcolor; border-image: none; background-image: none;" src="https://www.schaikweb.net/blog/20200418/8_inputactiontypes.png" border="0"></p><p>I am not sure if I got all the details right, but this is what I found out:</p><ul><li>a <em>digital</em> event, that's basically a click. You need to have a behaviour that implements IMixedRealityInputHandler to intercept this. Example: a click on the menu button </li><li>a <em>single axis</em> event is an event that gives you a single value. The only application for WMR controllers I have found is a way to determine how far the trigger is pushed inwards (on a scale of 0-1). You will need to implement IMixedRealityInputHandler&lt;float&gt;</li><li>a <em>dual</em> <em>axis</em> event gives you two values. The only application I found was the touchpad - it gives to the X,Y coordinates where the touchpad was <em>touched. </em>Range for both is -1 to 1. 0,0 is the touchpad's center. You will need to implement IMixedRealityInputHandler&lt;Vector2&gt;</li><li>a <em>six dof </em>(degrees of freedom) event will give you a MixedRealityPose. This enables you to determine the current grip and pointer pose of the controller. <em> </em>You will need to implement IMixedRealityInputHandler&lt;MixedRealityPose&gt;</li></ul><h2>Demo application</h2><p>I created an <a href="https://github.com/LocalJoost/MRKT2WMRController" target="_blank">application that demonstrates</a> the events you will get and what type they are. If available, it will also display the values associated with the event. It looks like this:</p><p><img width="640" height="428" style="border: 0px currentcolor; border-image: none; background-image: none;" src="https://www.schaikweb.net/blog/20200418/9_demoitems.png" border="0"></p><p>Not very spectacular, I'll admit, but it does the trick. On the top row it displays the <em>type</em> of event intercepted, the bottom two rows show actual events with - in four cases - information associated with the events. When activated: the red circle will turn green.</p><h2>Observations using the demo app</h2><ul><li>You will notice you'll get a constant stream of Grip Pose and Pointer Pose events - hence these two events and the MixedRealityPose type events indicator are always green</li><li>You will also get a constants stream of "Teleport Direction" events (of type Vector2) from the thumbstick even if you don't touch it. I have no idea why this is so. I had to filter those out, or else the fact Touchpad position is a Vector2 element got hidden in the noise.</li><li>Grip press is supposed to be a SingleAxis event, but only fires Digital events</li><li>If you touch the touchpad, it actually fires <em>two</em> events simultaneously - the Digital Touchpad Touch and the Vector2 Touchpad position. </li><li>Consequently, if you <em>press</em> the touchpad, you get three events - Touchpad touch, Touchpad Position and Touchpad Press.</li><li>The trigger button also is an interesting story as that fires three events as well. As soon start to press it ever so slightly, it fires the SingleAxis event "Trigger" that tells you how far the trigger is depressed. But at the lowest scale where "Trigger" registers, it will <em>also </em>fire the Digital "Trigger Touch" event. However, you will usually get a lot more "Trigger" events as it's very hard to keep the trigger perfectly still while it's halfway depressed. </li><li>And finally, when you fully press it, the Digital "Select" event will be fired.</li><li>Menu and Thumbstick press are simple Digital events as you would expect.</li></ul><h2>Key things to learn from the demo app</h2><h3>Registering global handlers</h3><p>On top you will see the the ControllerInputHandler implementing being derived from BaseInputHandler and the four interfaces mentioned. </p><pre style="font-size: 12px;">public class ControllerInputHandler : BaseInputHandler, 
    IMixedRealityInputHandler, IMixedRealityInputHandler&lt;Vector2&gt;, 
    IMixedRealityInputHandler&lt;float&gt;,
    IMixedRealityInputHandler&lt;MixedRealityPose&gt;</pre><p>The important thing to realize is that this behaviour needs to handle <em>global</em> events. This implicates two things, first, you will have to register global handlers</p><pre style="font-size: 11px;">protected override void RegisterHandlers()
{
    CoreServices.InputSystem?.RegisterHandler&lt;IMixedRealityInputHandler&gt;(this);
    CoreServices.InputSystem?.RegisterHandler&lt;IMixedRealityInputHandler&lt;Vector2&gt;&gt;(this);
    CoreServices.InputSystem?.RegisterHandler&lt;IMixedRealityInputHandler&lt;float&gt;&gt;(this);
    CoreServices.InputSystem?.RegisterHandler&lt;IMixedRealityInputHandler&lt;MixedRealityPose&gt;&gt;(this);
};</pre><p>(and unregister them of course in UnregisterHandlers)</p><p>but second, if you use this in Unity, uncheck the "Is Focus Required" checkbox</p><p><img width="400" height="100" style="border: 0px currentcolor; border-image: none; background-image: none;" src="https://www.schaikweb.net/blog/20200418/10_uncheckfocus.png" border="0"></p><p>This will ensure the global handlers being registered properly and being intercepted by this controller.</p><h3>Discriminating between events of same type</h3><p>It might not be immediately clear, but the only way <em>I</em> have been able to determine what exact event I get is to check it's MixedRealityInputAction.Description property. In the code you will seen things like</p><pre style="font-size: 12px;">var eventName = eventData.MixedRealityInputAction.Description.ToLower();
if (eventName == "touchpad position")
</pre><p>In fact, you will see that the names of the event displayers in Scene hierachy are bascially the names of the events without spaces. I simply find them by name</p><p><img width="175" height="202" style="border: 0px currentcolor; border-image: none; background-image: none;" src="https://www.schaikweb.net/blog/20200418/11_eventdisplayers.PNG" border="0"></p><p>After I simply load them in a dictionary in Start by looking for children in the "Events" object <pre style="font-size: 12px;">foreach (var controller in _eventDisplayParent.GetComponentsInChildren&lt;SingleShotController&gt;())
{
    _eventDisplayers.Add(controller.gameObject.name.ToLower(), controller);
}</pre>

I simply find the back by looking in that dictionary and activating the SingleShot Controller. This class is part of a prefab that <a href="https://localjoost.github.io/2019/09/26/migrating-to-mrtk2-setting-up-and.html" target="_blank">I used and explained in an earlier post</a>.<pre style="font-size: 12px;">private void ShowEvent(string eventName)
{
    var controller = GetControllerForEvent(eventName);
    if (controller != null)
    {
        controller.ShowActivated();
    }
}
private SingleShotController GetControllerForEvent(string controllerEvent)
{
    return _eventDisplayers[controllerEvent.ToLower().Replace(" ", "")];
}</pre><p>I must say I feel a bit awkward about having to use strings to determine events by name. I guess it's inevitable if you want to be able to support multiple platforms and be able to add and modify events without actually having to change code and introduce types. This flexibility is what the MRTK2 intends to support, but it still feels weird.</p><h3>Combining events</h3><p>In the Immersive headset version of <a href="https://www.microsoft.com/store/productId/9P6SVQQCP2SQ" target="_blank">Walk the World</a> you can zoom in or out by pressing on top of at the bottom at of the touch pad. But as we have seem, it's not even possible to detect where the user has pressed, only <em>that</em> he has pressed. But we can detect where he last <em>touched, </em>which most likely is at or very near where he last touched. How you can combine these the touch and press events to deserve and effect like I just described, is showed in the relevant pieces of the <a href="https://github.com/LocalJoost/MRKT2WMRController" target="_blank">demo project</a> code that copied below:</p><pre style="font-size: 12px;">Vector2 _lastpressPosition;

public void OnInputChanged(InputEventData&lt;Vector2&gt; eventData)
{
    var eventName = eventData.MixedRealityInputAction.Description.ToLower();
    if (eventName == "touchpad position")
    {
        _lastpressPosition = eventData.InputData;
    }
}

public void OnInputDown(InputEventData eventData)
{
    var eventName = eventData.MixedRealityInputAction.Description.ToLower();
    if (eventName == "touchpad press")
    {
        // Limit event capture to only when more or less the top or bottom 
        // of the touch pad is pressed
        if (_lastpressPosition.y &lt; -0.7 || _lastpressPosition.y &gt; 0.7)
        {
            ShowEvent(eventName);
        }
    }
}</pre><p>First, the touchpad position event keeps the last position into a member variable, then when the touchpad is pressed, we check where it last was touched. The event is only fired when the front 30% or back 30% was last touched before it was pressed. If you press the sides (or actually, touch the side before you press) nothing happens. </p><h2>Conclusion</h2><p>Interacting with the controller has changed quite a bit since ye olde days of the HoloToolkit, but it still is pretty much doable and usable if you follow the rules and patterns above. I still find it odd I have to determine what event is fired by checking it's description, but I may just be missing something. However, this method works for me, at least in my application.</p><p>Also, I am a bit puzzled by the almost-the-same-but-not-quite-so events around trigger and touchpad. No doubt some serious considerations have been made implementing it like this, but not having been around while that happens, it leaves confused about the why. </p><p>Finally, bear in mind you usually don't have to trap Select manually, and neither is the Thumbstick ('Teleport Direction') usually very interesting as those events are handled by the environment by default - the only reason I showed they them here was to demonstrate you <em>could</em> actually intercept them.</p><p>Demo project, as always, <a href="https://github.com/LocalJoost/MRKT2WMRController" target="_blank">here on GitHub</a>. </p>