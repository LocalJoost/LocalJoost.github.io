---
layout: post
title: A behavior to replace LayoutAwarePage in Windows Store and Windows Phone apps
date: '2014-02-23T19:20:00.000+01:00'
orgauthor: Joost van Schaik
tags:
- Windows Phone 8
- windev
- wpnl
- wpdev
- dotnetmag
- Windows 8
- XAML
- behavior
- Win8nl
modified_time: '2014-02-23T20:12:24.955+01:00'
blogger_id: tag:blogger.com,1999:blog-5295746446529817470.post-6124624112563496432
blogger_orig_url: https://dotnetbyexample.blogspot.com/2014/02/a-behavior-to-replace-layoutawarepage.html
comment_issue_id: 168
---

<p>Sometimes I think up things all by myself, sometimes I have to read something first to let the ole’ light bulb in my brain go ‘ping’. This post is of the 2nd category, and was inspired by <a href="http://irisclasson.com/2013/12/16/visualstates-and-the-missing-snapped-mode-made-easy-in-windows-store-apps/" target="_blank">this brilliant piece</a> by C# MVP <a href="https://twitter.com/irisclasson" target="_blank">Iris Classon</a> who is – apart from a very smart and respected coder – also a living and shining (not to mention <em><font color="#ff0000">colorful</font></em>) axe at the root of the unfortunate gender bigotry that is still widespread in the IT world – a lot of people still think seem convinced “women can’t code, if they do they do it badly, and those who do are socially inept, boring and ugly”. Which is demonstrably untrue – coding requires just a brain and determination - but I am convinced it still shies a lot of brain power out of IT. </p> <p>Anyway – what I basically did was take Iris’ idea an turn it into – you guessed it – a behavior, to make it more reusable. </p> <p>To demonstrate how it works, I created the following Store app with a very compelling UI:</p> <p><a href="http://www.schaikweb.net/dotnetbyexample/d7dc62be453c_7DE4/image.png"><img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="image" src="http://www.schaikweb.net/dotnetbyexample/d7dc62be453c_7DE4/image_thumb.png" width="644" height="318"></a></p> <p>There is only one text of 75pt there. And then I created three Visual States:</p> <ul> <li>Default, which does basically nothing  <li>Medium, which changes the font size to 50pt  <li>Small, which changes the font size to 25pt</li></ul> <p>How this is done is amply explained by Iris’ post so I don’t feel very compelled to repeat that here. After creating the states I brought in my <a href="http://wpwinnl.codeplex.com/" target="_blank">WpWinNl</a> nuget package, and added my new SizeVisualStateChangeBehavior to the page. Then I added three entries to “SizeMappings” to the behavior by clicking on the indicated ellipses on the right: </p> <p><a href="http://www.schaikweb.net/dotnetbyexample/d7dc62be453c_7DE4/image_4.png"><img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="image" src="http://www.schaikweb.net/dotnetbyexample/d7dc62be453c_7DE4/image_thumb_4.png" width="644" height="371"></a></p> <ul> <li>“Default” with width 801  <li>“Medium” with width 800  <li>“Small” with width 500</li></ul> <p>From 801 up to infinity the the Default state will be used (showing the text in it’s default size), between 800 and 501 the Medium state will be used (50pt), and from 500 and lower, the Small state (25pt). And voilá, automatic sizing of items done by filling in some boxes in Blend – or typing in some XAML in Visual Studio if that’s more of your thing. Notice you can add any number of Visual States for any range of widths, just as long as there is one “Default” state that has a width that’s one higher than the largest none-default width. Notice SizeVisualStateMappings can have any name you like as well, as long as they correspond with names of Visual States.</p> <p>For extra credit, by the way, I made this behavior attachable to Control objects rather than Page, so it can be used inside (user) controls as well. And with some #ifdef directives it also works for <a href="http://www.microsoft.com/windowsphone/?ocid=aff-n-we-loc--ITPRO40939&amp;WT.mc_id=aff-n-we-loc--ITPRO40939">Windows Phone</a>, which might come in handy with more and more of resolutions entering the Windows Phone arena.</p> <p>As to how this behavior works, it’s not quite rocket science. First, we have this hugely complex class :-P that holds one SizeVisualStateMapping:</p><pre>namespace WpWinNl.Behaviors
{
  public class SizeVisualStateMapping
  {
    public string VisualState { get; set; }
    public int Width { get; set; }
  }
}</pre>
<p>The actual behavior’s setup almost immediately shows what I am doing – I simply latch on to the SizeChanged event of the object that the behavior is attached to:</p><pre>using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
#if WINDOWS_PHONE
using System.Windows;
using System.Windows.Controls;
#else
using Windows.UI.Xaml;
using Windows.UI.Xaml.Controls;
#endif

namespace WpWinNl.Behaviors
{
  public class SizeVisualStateChangeBehavior : SafeBehavior&lt;Control&gt;
  {
    protected override void OnSetup()
    {
      AssociatedObject.SizeChanged += AssociatedObjectSizeChanged;
      base.OnSetup();
      UpdateVisualState();
    }
    
    private void AssociatedObjectSizeChanged(object sender, SizeChangedEventArgs e)
    {
      UpdateVisualState();
    }
  }
}</pre>The core of the behavior’s functionality is the UpdateVisualState method:<pre>private void UpdateVisualState()
{
  if (SizeMappings != null)
  {
    SizeVisualStateMapping wantedMapping = null;
    var wantedMappings = <br>         SizeMappings.Where(p =&gt; p.Width &gt;= AssociatedObject.ActualWidth);
    if (wantedMappings.Any())
    {
      wantedMapping = wantedMappings.OrderBy(p =&gt; p.Width).First();
    }
    else
    {
      var orderedMappings = SizeMappings.OrderBy(p =&gt; p.Width);
      if (AssociatedObject.ActualWidth &lt; orderedMappings.First().Width)
      {
        wantedMapping = orderedMappings.First();
      }
      else if (AssociatedObject.ActualWidth &gt; orderedMappings.Last().Width)
      {
        wantedMapping = orderedMappings.Last();
      }
    }

    if (wantedMapping != null)
    {
      VisualStateManager.GoToState(AssociatedObject, wantedMapping.VisualState, <br>                                   false);
    }
  }
}</pre>
<p>Which simply tries to find a SizeVisualStateMapping that’s fit for the current width of the associated object. If it finds that, it tells the VisualStateManager to go to that state, which proceeds to do the actual work. And that’s basically all. All that's left are an Dependency Property SizeMapping of type List&lt;SizeVisualStateMapping&gt; SizeMappings that holds the actual mapings, and a Cleanup method that detaches the behavior from the SizeChanged event again.</p>
<p>Full details, and <a href="http://www.schaikweb.net/dotnetbyexample/DemoSizeVisualStateChangeBehavior.zip" target="_blank">a working solution including this behavior, can be found here</a>. If you run this app in split screen and slowly makes it’s window width smaller, you will notice the text getting smaller. Be aware that the change only fires when you actually let the window divider control go – as long as you keep it active (by touching or dragging it) nothing will happen.</p>  
