---

title: Creating a 3D topographical map in your HoloLens / Windows MR app with the Bing Maps Elevation API
date: '2017-08-02T12:03:00.000+02:00'
orgauthor: Joost van Schaik
tags:
- UWP
- HoloLens
- Windows Mixed Reality
- Mapping
- Unity3D
modified_time: '2017-08-03T07:59:20.348+02:00'
thumbnail: https://lh3.googleusercontent.com/-3dLtZb2cRAI/WYGjb3AUXaI/AAAAAAAAPK8/xptSYRko00Q0JTHF-RlDLNLqgNedSnuFQCHMYCw/s72-c/image_thumb%255B3%255D?imgmax=800
blogger_id: tag:blogger.com,1999:blog-5295746446529817470.post-8911723110347363840
blogger_orig_url: https://dotnetbyexample.blogspot.com/2017/08/creating-3d-topographical-map-in-your.html
---

<h2>Intro</h2><p>All right, my friends. It's time for the real deal, the blog post I have been anticipating to write since I first published the 3D version of <a href="https://www.microsoft.com/store/productid/9P6SVQQCP2SQ" target="_blank">Walk the World</a> like two months ago. It took me a while to extract the minimal understandable code from my rather convoluted app. Everyone who has ever embarked on a trip of 'exploratory programming' (meaning you have an idea what you want to do, but only some vague clues how) knows how you end up with a repo (and code) full of failed experiments, side tracks, etc. So I had to clean that up a little first. Also, my app does a lot more than just show the map, and those features would obscure the general idea. As a bonus - after creating this blog post I finally actually understand myself how and most importantly <em>why</em> the app works :).</p><p>So, without further ado, I am going to show you how to display a 3D map in your HoloLens or Windows MR headset. Just like in Walk the World. I will build upon <a href="http://localjoost.github.io/create-geographical-map-on-floor-in" target="_blank">my previous post, in which I showed you how to make a flat slippy map</a>. This time, we are going 3D.</p><h2>The general idea</h2><p>As you can read in <a href="http://localjoost.github.io/create-geographical-map-on-floor-in" target="_blank">the previous post</a>, I 'paste' the actual map tiles - mere images - on a Unity3D Plane. A Plane is a so-called mesh that exists out of a grid of 11x11 points, that form the vertices. If I somehow would be able to ascertain actual elevation on those locations, I can move those points up and down and actually get a 3D map. The tile itself will be stretched up and down.The idea of manipulating the insides of a mesh, which turns out to be very simple, is explained by the awesome <a href="https://twitter.com/rickbarraza" target="_blank">Rick Bazarra</a> in the <a href="https://www.youtube.com/watch?v=a-quaXuEdhU&amp;list=PL64OnOdZ_3NF4iv53e8eG7t1erC1PgKx6" target="_blank">first episode of his must-see "Unity Strikes Back" explanatory video series</a> on YouTube, a follow-up to his <a href="https://channel9.msdn.com/Series/UnityCreativeCoding" target="_blank">Creative Coding with Unity series</a> on Channel 9, that I consider a standard starting point for everyone who wants to get off the ground with Unity3D.</p><p>So where do we get those elevations? Enter the awesome Microsoft service called the <a href="https://msdn.microsoft.com/en-us/library/jj158961.aspx" target="_blank">Bing Maps Elevation API</a>. It seems to be built-to-order for this task. Your first order of business - <a href="https://www.bingmapsportal.com/" target="_blank">get yourself a Basic Bing Maps key</a>. </p><h2>Adding some geo-intelligence to the tile</h2><p>The Bing Maps Elevation API documentation describes an endpoint <a href="https://msdn.microsoft.com/en-us/library/jj158961.aspx" target="_blank">GetElevations</a> that allows you to get altitudes in several ways. One of them is a grid of altitudes in a bounding box. That is what we want - our tiles are square. The documentation says the bounding box should be specified as follows:</p><p><strong>"A bounding box defined as a set of WGS84 latitudes and longitudes in the following order: <br>
south latitude, west longitude, north latitude, east longitude"</strong></p><p>If you envision a tile positioned so that north is up, we are required to calculate the geographical location of the top-right and bottom-left of the tile. The Open Street Maps Wiki provides <a href="http://wiki.openstreetmap.org/wiki/Slippy_map_tilenames#C.23" target="_blank">code for the north-west corner of the tile</a>, i.e. top <em>left. </em>I translated the code to C#...</p><pre style="font-size: 11px;">//http://wiki.openstreetmap.org/wiki/Slippy_map_tilenames#C.23
private WorldCoordinate GetNorthWestLocation(int tileX, int tileY, int zoomLevel)
{
    var p = new WorldCoordinate();
    var n = Math.Pow(2.0, zoomLevel);
    p.Lon = (float)(tileX / n * 360.0 - 180.0);
    var latRad = Math.Atan(Math.Sinh(Math.PI * (1 - 2 * tileY / n)));
    p.Lat = (float) (latRad * 180.0 / Math.PI);
    return p;
}</pre><p><a href="https://lh3.googleusercontent.com/-VU4tXizvfr4/WYGjbftVWNI/AAAAAAAAPK4/lotZoDHjz7grl7jeIcF5KjqNbCGh96XSACHMYCw/s1600-h/image%255B5%255D"><img width="124" height="122" title="image" align="right" style="border: 0px currentcolor; border-image: none; float: right; display: inline; background-image: none;" alt="image" src="https://lh3.googleusercontent.com/-3dLtZb2cRAI/WYGjb3AUXaI/AAAAAAAAPK8/xptSYRko00Q0JTHF-RlDLNLqgNedSnuFQCHMYCw/image_thumb%255B3%255D?imgmax=800" border="0"></a>... and it works fine, but we need the <em>south west</em> and the <em>north east</em> points. Well, if you consider how the tiles are stacked, you can easily see how the north east point is the north-west point of the tile <em>right</em> of our current tile, and the south-west point is the north west point of the tile <em>below</em> our tile. Therefore we can use the north-west points of those adjacent tiles to find the values we actually need - like this:</p><pre style="font-size: 11px;">public WorldCoordinate GetNorthEast()
{
    return GetNorthWestLocation(X+1, Y, ZoomLevel);
}

public WorldCoordinate GetSouthWest()
{
    return GetNorthWestLocation(X, Y+1, ZoomLevel);
}
</pre><p>That was easy, right?</p><h2>Size matters</h2><p>Although Microsoft is a USA company, it fortunately has an international orientation so the Bing Maps Elevation API returns no yards, feet, inches, miles, furlongs, stadia, or any other <a href="http://www.zmescience.com/other/map-of-countries-officially-not-using-the-metric-system/" target="_blank">deprecated distance unit</a> – it returns plain old meters. Which is very fortunate, as the Windows Mixed Reality distance unit is – oh joy – meters too. But it returns elevation in <em>real world values</em>, and while it might be fun to show Kilimanjaro in real height, it will be a bit too big to fit in my room (or any room, for what matters). Open Street Map is shown at a definite scale per zoom level – and as a GIS guy, I like to be the height correctly scaled - to get for this real life feeling. Once again, referring to the Open Street Map Wiki – there is a nice table that shows <a href="http://wiki.openstreetmap.org/wiki/Zoom_levels" target="_blank">how many meters a pixel is at any given zoom level</a>. We will need the size per <em>tile </em>(which is 256 pixels, as I explained in the previous post), so we add the following code that will give you a scale factor for the available zoom levels for Open Street Map:</p><pre style="font-size: 11px;">//http://wiki.openstreetmap.org/wiki/Zoom_levels
private static readonly float[] _zoomScales =
{
    156412f, 78206f, 39103f, 19551f, 9776f, 4888f, 2444f,
    1222f, 610.984f, 305.492f, 152.746f, 76.373f, 38.187f,
    19.093f, 9.547f, 4.773f, 2.387f, 1.193f, 0.596f, 0.298f
};

private const int MapPixelSize = 256;

public float ScaleFactor
{
    get { return _zoomScales[ZoomLevel] * MapPixelSize; }
}</pre><h2>Creating the request</h2><p>Now we move to MapTile. We add the following code to download the Bing Maps Elevation API values</p><pre style="font-size: 10px;">private string _mapToken = "your-map-token-here";

public bool IsDownloading { get; private set; }

private WWW _downloader;

private void StartLoadElevationDataFromWeb()
{
    if (_tileData == null)
    {
        return;
    }
    var northEast = _tileData.GetNorthEast();
    var southWest = _tileData.GetSouthWest();

    var urlData = string.Format(
    "http://dev.virtualearth.net/REST/v1/Elevation/Bounds?bounds={0},{1},{2},{3}&amp;rows=11&amp;cols=11&amp;key={4}",
     southWest.Lat, southWest.Lon, northEast.Lat, northEast.Lon, _mapToken);
    _downloader = new WWW(urlData);
    IsDownloading = true;
}</pre><p>This simply queries the TileInfo structure for the new methods we have just created. Notice it then builds the URL, containing the bounds, the hard coded 11x11 points that are in a Unity Plane, and the key. Then it calls a piece of Unity3D code called “WWW”&nbsp; which is a sort of HttpClient named by someone with a <em>lot</em> of fantasy (NOT). And that’s it. We add a call to the existing SetTileData method like this:</p><pre style="font-size: 12px;">public void SetTileData(TileInfo tiledata, bool forceReload = false)
{
    if (_tileData == null || !_tileData.Equals(tiledata) || forceReload)
    {
        TileData = tiledata;
        <strong><font color="#ff0000">StartLoadElevationDataFromWeb();</font></strong>
    }
}</pre><p>so that whenever tile data is supplied, it does not only initiate the downloading of the tile, but also the downloading of the 3D data.</p><h2>Processing the 3D data</h2><p>Next up is a method ProcessElevationDataFromWeb, that is called from Update (so about 60 times a second). In this method we check if a the MapTile is downloading – and if it’s ready, we process the data</p><pre style="font-size: 12px;">protected override void OnUpdate()
{
    ProcessElevationDataFromWeb();
}

private void ProcessElevationDataFromWeb()
{
    if (TileData == null || _downloader == null)
    {
        return;
    }

    if (IsDownloading &amp;&amp; _downloader.isDone)
    {
        IsDownloading = false;
        var elevationData = JsonUtility.FromJson&lt;ElevationResult&gt;(_downloader.text);
        if (elevationData == null)
        {
            return;
        }

        ApplyElevationData(elevationData);
    }
}</pre><p>An ElevationResult is a class to deserialize a result from a call to the Bing Maps Elevation API in. I entered the result of a manual call in <a href="http://json2csharp.com/" target="_blank">Json2CSharp</a> and got a class structure back – only I changed all properties into public fields so the rather <strike>stupid</strike> limited Unity JsonUtility, that does not seem to understand the concept of properties, can handle it. I also initialized lists in the objects from the constructors. It’s not very interesting but if you want a look go <a href="https://github.com/LocalJoost/SlippyMapDemo/blob/3D/Assets/App/Scripts/ElevationResult.cs" target="_blank">here in the demo project.</a><font color="#000000"></font></p><h2>Applying the 3D data.</h2><p>So now it’s time to actually move the mesh points up an down. Mostly using code I stole from Rick Bazarra, with a few adaptions from me:</p><pre style="font-size: 11px;">private void ApplyElevationData(ElevationResult elevationData)
{
    var threeDScale = TileData.ScaleFactor;

    var resource = elevationData.resourceSets[0].resources[0];

    var verts = new List&lt;Vector3&gt;();
    var mesh = GetComponent&lt;MeshFilter&gt;().mesh;
    for (var i = 0; i &lt; mesh.vertexCount; i++)
    {
        var newPos = mesh.vertices[i];
        newPos.y = resource.elevations[i] / threeDScale;
        verts.Add(newPos);
    }
    RebuildMesh(mesh, verts);
}

private void RebuildMesh(Mesh mesh, List&lt;Vector3&gt; verts)
{
    mesh.SetVertices(verts);
    mesh.RecalculateNormals();
    mesh.RecalculateBounds();
    DestroyImmediate(gameObject.GetComponent&lt;MeshCollider&gt;());
    var meshCollider = gameObject.AddComponent&lt;MeshCollider&gt;();
    meshCollider.sharedMesh = mesh;
}</pre><p>First we get the scale factor – that’s simply the value by which elevation data must be divided to make it match the current zoom level. Next, we get the elevation data itself, that is two levels down in de ElevationData. And then we go modify the elevation of the mesh points to match those of the elevation we got. For some reason - and that's why I said it looks like the Bing Maps Elevation API looks to be like built-to-order for this task - the points come in at exactly the right order for Unity to process in the mesh. </p><p>As I learned from Rick, you cannot modify the points of a mesh, you have to <em>replace</em> them. So we loop through the mesh points and fill a list with points that have their y – so the vertical direction – changed to a scaled value of the elevation. Then we call RebuildMesh, that simply replaces the entire mesh with new vertices, does some recalculation and rebuilds the collider, so your gaze cursor will actually play nice with the new mesh. I also noticed that it you don’t do the recalculate stuff, you will end up looking partly through tiles. I am sure people with a deeper understanding of Unity3D will understand why. I just found out that it needs to be done.</p><p>Don't press play yet! There a few tiny things left to do, to make the result look good. </p><h2>Setting the right location and material</h2><p>First of all, the map is kind of shiny, which was more or less okay-ish for the flat map, but if you turn the map into 3D you will get this over bright effect. So open up the project in Unity, create a new material “MapMaterial” and apply the properties as displayed here below left. The color of the material should be #BABABAFF. See left image. When it is done, drag it on top of the MapTile (see right image). </p><p><a href="https://lh3.googleusercontent.com/-UjGGhFj0LPQ/WYHilfQuPfI/AAAAAAAAPLM/a3nDHuPMbfwj6KbnBcBvuL5fo5BP2iVsQCHMYCw/s1600-h/image%255B17%255D"><img width="300" height="468" title="image" style="border: 0px currentcolor; border-image: none; display: inline; background-image: none;" alt="image" src="https://lh3.googleusercontent.com/-5R6qkw82gV4/WYHil6PaJtI/AAAAAAAAPLQ/FC2214zEma4QwnyFfiisht-5YrzieXFEACHMYCw/image_thumb%255B11%255D?imgmax=800" border="0"></a><a href="https://lh3.googleusercontent.com/-1JnscMuDaUc/WYK7Y4TzZEI/AAAAAAAAPMg/A9NWh54IT0oNGsFnJ0XqEHBmSLnuQOGlACHMYCw/s1600-h/image12%255B2%255D"><img width="300" height="444" title="image" align="right" style="border: 0px currentcolor; border-image: none; float: right; display: inline; background-image: none;" alt="image" src="https://lh3.googleusercontent.com/-HBqL8F7AYrA/WYK7Zfc9qbI/AAAAAAAAPMk/zJJHQfVywGY3Bhfnn-DZAnmiLAHK7UtQACHMYCw/image12_thumb%255B1%255D?imgmax=800" border="0"></a></p><p>Then, the app is still looking at Redmond. While that’s an awesome place, there isn’t much spectacular to see as far as geography is concerned. So we mosey over to the MapBuilder script. There we change the zoom level to 14, the Latitude to 46.78403 and the Longitude to -121.7543</p><p><a href="https://lh3.googleusercontent.com/-OptUWt6NHo4/WYHinQwycxI/AAAAAAAAPLc/GtIFb1prxgAwCOg1FzK4m9vuu0GXSxMKgCHMYCw/s1600-h/image%255B4%255D"><img width="650" height="287" title="image" style="border: 0px currentcolor; border-image: none; display: inline; background-image: none;" alt="image" src="https://lh3.googleusercontent.com/-CrSmFC-DMwA/WYHin-keZdI/AAAAAAAAPLg/G9o4rQEndsQj6kmaEvi3S6jCYoeIn_UHACHMYCw/image_thumb%255B2%255D?imgmax=800" border="0"></a></p><p>It's a little east and quite a bit more south from Redmond. In fact, when you press play, you will see a landmark that is very familiar if you live anywhere near the Seattle area or visited it:</p><p><a href="https://lh3.googleusercontent.com/-TVd8--50duU/WYH6S9iDJSI/AAAAAAAAPL0/sMyPao0uqdoQ0BC0aB-unbaxYyqyE-A7gCHMYCw/s1600-h/image%255B5%255D"><img width="654" height="547" title="image" style="border: 0px currentcolor; border-image: none; display: inline; background-image: none;" alt="image" src="https://lh3.googleusercontent.com/-83TUh9Cz-_0/WYH6TdMfDVI/AAAAAAAAPL4/-EBznxT6VSQyF0ma4JY-iIZJJoGHIahBQCHMYCw/image_thumb%255B2%255D?imgmax=800" border="0"></a></p>
<p>famous Mount Rainier, the volcano sitting about 100 km from Seattle, very prominently visible from aircraft - weather permitting. To get this view, I had to fiddle with the view control keys a little after pressing play - if you press play initially you will see Rainier from a lot more close up.</p><p align="left">And that, my friends, is how you make a 3D map in your HoloLens. Of <em>almost</em> <em>any place in the world</em>. Want to see Kilimanjaro? Change Latitude to -3.21508 and Longitude to 37.37316. Press play. </p><p align="left"><a href="https://lh3.googleusercontent.com/-K8LXVA8_F_Y/WYH6UrC7xxI/AAAAAAAAPL8/nUeHreXUtYc5KHx5c9W-BM4m8yp7SLKyACHMYCw/s1600-h/image%255B10%255D"><img width="650" height="544" title="image" style="border: 0px currentcolor; border-image: none; display: inline; background-image: none;" alt="image" src="https://lh3.googleusercontent.com/-h8BqeMh7_PA/WYH6VrZr9OI/AAAAAAAAPMA/IZe7QxZ9xTsxrYPl8C7vXRZxZUNOoeqsQCHMYCw/image_thumb%255B5%255D?imgmax=800" border="0"></a></p><p>Niagra falls? Latitude 43.07306, Longitude -79.07561 and change zoom level to 17. Rotate the view forward a little with your mouse and pull back. You have to look <em>down</em>. But then, here you go.</p><p><a href="https://lh3.googleusercontent.com/-PRQWQ2TdwE4/WYH6WMBxLCI/AAAAAAAAPME/JN58YHrl5TsrrBGi1d9nUgBYgjAYTBUhgCHMYCw/s1600-h/image%255B15%255D"><img width="650" height="544" title="image" style="border: 0px currentcolor; border-image: none; display: inline; background-image: none;" alt="image" src="https://lh3.googleusercontent.com/-J6zK11IlCVw/WYH6XMTVlTI/AAAAAAAAPMI/7l1Nbz9FBAk3PvUaALQ3UurlOeU_BT2JwCHMYCw/image_thumb%255B8%255D?imgmax=800" border="0"></a></p><p>GIS is cool, 3D GIS is ultra-cool! All that is left is to generate the UWP app and deploy it into your HoloLens or view it in your new <a href="https://developer.microsoft.com/en-us/windows/mixed-reality" target="_blank">Windows Mixed Reality</a> device.</p><h2>Caveat emptor</h2><p>Awesome right?&nbsp; Now there are a few things to consider. In my <a href="http://localjoost.github.io/create-geographical-map-on-floor-in" target="_blank">previous post</a> I said this app was a bandwidth hog, as it downloads 169 tiles <em>per map</em>. In addition, it now also fires 169 requests per map to the Bing Maps Elevation API. For. Every. Single. Map. Every time. Apart from the bandwidth and power consequences, there's another thing to consider. If you go to <a href="https://www.microsoft.com/maps/create-a-bing-maps-key.aspx" target="_blank">this page</a> and click "Basic Key", you will see something like this:</p><p><a href="https://lh3.googleusercontent.com/-1g4q2kb-Hn4/WYH6Xp_R_MI/AAAAAAAAPMM/9vORsj6urU4u3Ptwx23mmtxPxA7gTBuRACHMYCw/s1600-h/image%255B20%255D"><img width="650" height="317" title="image" style="border: 0px currentcolor; border-image: none; display: inline; background-image: none;" alt="image" src="https://lh3.googleusercontent.com/-JZvno63Mipo/WYH6YDMR1DI/AAAAAAAAPMQ/1DJdspmcWUgy6N6uh9d38zM1MbBH7X2JwCHMYCw/image_thumb%255B11%255D?imgmax=800" border="0"></a></p><p>What is boils down to is - if your app is anywhere near successful, it will eat your allotted request limit <em>very fast</em>, you will get a mail from the Bing Team kindly informing you of this (been there, got that) - and then suddenly you will have a 2D app again. You will have to buy and enterprise key and those are <em>not</em> cheap. So I advise you to do some caching - both in the app and if possible on an Azure service. I employed a Redis cache to that extent.</p><p>Furthermore, I explained I calculate the north east and south west points of a tile using the north west points of the tiles left of and below the current tile. If those tiles are not present, because you are at the edge of the map, I have no idea what will happen - but presumably it won't work as expected. You can run into this when you are zoomed out sufficiently in the very south or east of the map. But then you are either at the <a href="https://en.wikipedia.org/wiki/International_Date_Line" target="_blank">International Date Line</a> (that runs from the North Pole to the South Pole exactly on the side of Earth that is exactly opposite of the <a href="https://en.wikipedia.org/wiki/Prime_meridian_(Greenwich)" target="_blank">Greenwich Meridian</a>) or at Antarctica. On the first spot, there’s mostly ocean (why else do you think they’ve put it there) and thus no (visible) geography to speak of. As far as Antarctica goes, you’ll hit another limitation, for it clearly says in the Bing Maps Elevation API documentation:</p><p><strong>"There is a limitation in that latitude coordinates outside of the range of -85 and 85 are not supported."</strong><p>So beware. Stay away from the Earth's edges. Your app might fall off :).<h2>Some assembly required, batteries not included</h2><p>Indeed, it does not look exactly <a href="https://www.youtube.com/watch?v=elbesPvRUXc&amp;t" target="_blank">like in the videos I showed</a>. Walk the World employs a different map tile sets (plural indeed), and there's also all kinds of other stuff my app does - like sticking the map to the floor so that even at high elevations you have a nice overview, reverse geocoding so you can click on the map to see what's there, tracking the user's moves so it can make a new map appear where the user is walking off it&nbsp; - connecting to the old one, zoom in/out centered on the user's location in the map, showing a map of the physical surroundings... there's a lot of math in there. I only showed you the basics. If you need a HoloDeveloper who knows and understand GIS to the core, you know who to contact now :)<h2>Conclusion</h2><p>Once you know the basics, it's actually pretty easy to create a 3D scaled map of about anywhere in the world, that is - anywhere where the Bing Maps Elevation API is supported. The 3D stuff is actually the <em>easy</em> part - knowing how to <a href="http://localjoost.github.io/create-geographical-map-on-floor-in" target="_blank">calculate tiles and build a slippy map</a> is harder. But in the end, it is always easy when you know what to do. Like I said, I think GIS is a premier field in which Mixed Reality will shine. I am ready for it: I hope you are too. Innovate or die - there are certainly companies I know that could take that advice and get moving.<p>Get the <a href="https://github.com/LocalJoost/SlippyMapDemo/tree/3D" target="_blank">demo project</a> and get inspired!<h2>Credits</h2><p>Thanks to <a href="https://twitter.com/rschu" target="_blank">René Schulte</a>, the wise man from 51.050409, 13.737262 ;)&nbsp; for pointing me to the Bing Maps Elevation API. And of course to <a href="https://twitter.com/rickbarraza" target="_blank">Rick Bazarra</a>, who inspired me so often and actually provided some crucial code in his YouTube training video series.