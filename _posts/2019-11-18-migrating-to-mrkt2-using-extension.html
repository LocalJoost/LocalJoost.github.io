---
layout: post
title: Migrating to MRKT2 - using extension services for dependency injection
date: '2019-11-18T16:53:00.001+01:00'
orgauthor: Joost van Schaik
tags:
- Unity
- Windows Mixed Reality
- MRTK2
- HoloLens2
modified_time: '2019-11-18T17:00:10.151+01:00'
blogger_id: tag:blogger.com,1999:blog-5295746446529817470.post-4531079482129288530
blogger_orig_url: https://dotnetbyexample.blogspot.com/2019/11/migrating-to-mrkt2-using-extension.html
comment_issue_id: 341
---

<h2>Intro</h2><p>Coming from business development, you might get a little shock coming into Unity - traditionally, game developers are much more focused on making the outside pretty than the inside. Things like dependency injection are kind of unheard of or considered 'too heavy' for game development. But if you are still in the process of development,&nbsp; actually being able to access a consistent (mock) data service in stead of the real live data service might be a big advantage, especially when that data service is rate limited or expensive.</p><p>The <a href="https://www.microsoft.com/en-us/windows/windows-mixed-reality" target="_blank"><a href="https://github.com/Microsoft/MixedRealityToolkit-Unity" target="_blank">Mixed Reality Toolkit</a> 2 offers a great feature for that: extension services. And it's actually pretty easy to use, and I am going to show a simple sample. I have written about this in very early alpha stage almost a year ago, but it's now to a point that it's actually usable.</p><h2>Setting the stage</h2><p>Using Unity 2018.4.6f1, I created a simple project MKRT2DepInject using the 3D template, imported the MRKT2 and TextMeshPro. For the latter I usually take essential resources only.Then I and added the MRKT2 to the SampleScene in the project. For the default profile, I usually take the DefaultHololens2Profile. Also, don't forget to set the platform to UWP (File/Build settings)</p><p>Also - and this is important - <a href="https://localjoost.github.io/migrating-to-mrtk2newtonsoftjson-aka" target="_blank">import JSON.net from the Unity store</a>.</p><h2>Extension services</h2><p>A service requires an interface, an implementing class, optionally an inspector, a profile, and a default profile asset. Now the latter three may sounds maybe a bit abstract but it actually boils down to this:</p><ul><li>An <em>inspector</em> is something that can be used to show the runtime status of a service in the editor. It's basically a debugging tool. It's entirely optional and in most cases it's not necessary.</li><li>A <em>profile</em> is a class holding configuration info for a class. If you have been using the MRKT2 for a while, you have been using them all along - cloning profiles and changing settings. </li><li>a default service profile asset is basically a serialized version of a profile class. </li></ul><p>This may seem like a lot of work, but there's actually a nice tool for generating the boiler plate for all that - although had to get in a few pull request myself to getting it to work as I assume was intended ;)</p><h2>Creating an extension service</h2><p>Select <a href="https://www.microsoft.com/en-us/windows/windows-mixed-reality" target="_blank">Mixed Reality</a> Toolkit/Utilities/Create Extension Service. This will bring up this UI:</p><p><font color="#ff0000"><img style="border: 0px currentcolor; border-image: none; background-image: none;" src="https://www.schaikweb.net/blog/20190311/createextension.png" border="0"></font></p><p>Name the service "DataService". You will notice the "Service" suffix is mandatory. Choose "Services" for namespace. Then click the "Next" button. This will show you the next stage. </p><p><font color="#ff0000"><img style="border: 0px currentcolor; border-image: none; background-image: none;" src="https://www.schaikweb.net/blog/20190311/defineextension.png" border="0"></font></p><p>Now I like to organize my stuff a little, so I tend to put things in folders. The scripts go in a scripts/services folder, the profile in profile. You can set this by dragging the folder from the assets. Notice also I have disabled the inspector:</p><p><font color="#ff0000"><img width="640" height="466" style="border: 0px currentcolor; border-image: none; background-image: none;" src="https://www.schaikweb.net/blog/20190311/setoptions.png" border="0"></font></p><p>Hit next, and on the next screen click <em>not now</em> because otherwise you will be editing the default profiles - effectively, you are modifying the <em>default settings </em>of the MRKT2. You can do this <em>only</em> after you have cloned the proper profiles.</p><p><font color="#ff0000"><img style="border: 0px currentcolor; border-image: none; background-image: none;" src="https://www.schaikweb.net/blog/20190311/registerservice.png" border="0"></font></p><p>You will also notice that although you specified the default asset should have been created in the Profiles folder, it is in fact created in the Services folder. Look I am going to need to make another pull request. Anyway. I moved the DefaultDataServiceProfile to profiles, and let it sit there</p><h2>Registering the service</h2><p>First, we clone the top profile. </p><p><font color="#ff0000"><img style="border: 0px currentcolor; border-image: none; background-image: none;" src="https://www.schaikweb.net/blog/20190311/clonetoolkitprofile.png" border="0"></font></p><p>Then we disable the profiler, because that's annoyingly in the way when you want to demo something</p><p><font color="#ff0000"><img style="border: 0px currentcolor; border-image: none; background-image: none;" src="https://www.schaikweb.net/blog/20190311/disablediag.png" border="0"></font></p><p>Then we select the Extensions tab, and clone the "DefaultMixedRealityRegisteredServiceProvidersProfile" (the creators of the MRTK2 seem to have taken a liking to rather verbose names, as you might have noticed) to MyMixedRealityRegisteredServiceProvidersProfile</p><p><font color="#ff0000"><img style="border: 0px currentcolor; border-image: none; background-image: none;" src="https://www.schaikweb.net/blog/20190311/cloneregisteredprovider.png" border="0"></font></p><p>Now you can actually click the "+ Register a new Service Provider" button and register the service</p><p><font color="#ff0000"><img width="544" height="297" style="border: 0px currentcolor; border-image: none; background-image: none;" src="https://www.schaikweb.net/blog/20190311/registerservicecomponent1.png" border="0"></font></p><p>Then you have to click the Configuration Profile drop down, which unfortunately shows you all possible profiles, and you have to pick the one you need, which is DefaultDataServiceProfile, which is fortunately at the top of the list</p><p><font color="#ff0000"><img style="border: 0px currentcolor; border-image: none; background-image: none;" src="https://www.schaikweb.net/blog/20190311/registerservicecomponent2.png" border="0"></font></p><p>The end result should look like this:</p><p><font color="#ff0000"><img style="border: 0px currentcolor; border-image: none; background-image: none;" src="https://www.schaikweb.net/blog/20190311/registerservicecomponent3.png" border="0"></font></p><p>Now the configuration stuff is finally done, and we are going to add some code.</p><h2>The data and the data set</h2><p>My simple sample is going to read a json file from the web and show the contents in the text. Therefore we need a data file, and a class to deserialize it in.</p><p>The data file sits <a href="https://www.schaikweb.net/demo/DemoData.json" target="_blank">here</a>, and the class in which in can be deserialized looks like this</p><pre style="font-size: 12px;">using Newtonsoft.Json;

namespace Json
{
    public class DemoData
    {
        [JsonProperty("firstName")]
        public string FirstName { get; set; }

        [JsonProperty("lastName")]
        public string LastName { get; set; }
    }
}</pre><h2>Configuration profile</h2><p>So to make the configuration profile actually configurable, the DataServiceProfile class needs to be changed. We actually need to make a property to store an URL in. So, we add a serializable field and a read only property. Like this:</p><pre style="font-size: 12px;">using System;
using UnityEngine;
using Microsoft.MixedReality.Toolkit;

namespace Services
{
    [MixedRealityServiceProfile(typeof(IDataService))]
    [CreateAssetMenu(fileName = "DataServiceProfile", 
        menuName = "MixedRealityToolkit/DataService Configuration Profile")]
    public class DataServiceProfile : BaseMixedRealityProfile
    {
<strong><font color="#ff0000">        [SerializeField]
        private string _dataUrl;

        public string DataUrl =&gt; _dataUrl;</font></strong>
    }
}</pre><p>Added code in red/bold. If you go back to the inspector, you will see there is a Data Url field now added to the DataService profile.</p><p><font color="#ff0000"><img width="500" height="271" style="border: 0px currentcolor; border-image: none; background-image: none;" src="https://www.schaikweb.net/blog/20190311/addedconfigfield.png" border="0"></font></p><p>So let's clone that default profile to SchaikwebProfile:</p><p><font color="#ff0000"><img src="https://www.schaikweb.net/blog/20190311/schaikwebprofile.png"></font></p><p>And enter for Data Url: <a title="https://www.schaikweb.net/demo/DemoData.json" href="https://www.schaikweb.net/demo/DemoData.json">https://www.schaikweb.net/demo/DemoData.json</a>. Result: </p><p><img width="493" height="270" style="border: 0px currentcolor; border-image: none; background-image: none;" src="https://www.schaikweb.net/blog/20190311/schaikwebprofileselected.png" border="0"><font color="#ff0000"></font></p><p>You can now already see how you can quickly change from one configuration profile to another. You could actually clone the schaikwebprofile to another profile with different settings. Now it has only one property, but it can have a lot - and you can change from one setting to another just by selecting a new profile.</p><h2>Implementing the actual service</h2><p>The generated code for the service - a bit abbreviated - looks like this:</p><pre style="font-size: 12px;">namespace Services
{
    [MixedRealityExtensionService(....
    public class DataService : BaseExtensionService, IDataService, 
      IMixedRealityExtensionService
    {
        private DataServiceProfile dataServiceProfile;

        public DataService(IMixedRealityServiceRegistrar registrar, ....) 
        {
            dataServiceProfile = (DataServiceProfile)profile;
        }

        public override void Initialize()
        {
            // Do service initialization here.
        }

        public override void Update()
        {
            // Do service updates here.
        }
    }
}</pre><p>You can see the profile - the class holding the settings - is being fed into the constructor. Now we don't need Initialize and Update in this simple service, so we delete that and add this:</p><pre style="font-size: 12px;">public async Task&lt;IList&lt;DemoData&gt;&gt; GetNames()
{
    using (var request = new HttpRequestMessage(HttpMethod.Post, 
                                                dataServiceProfile.DataUrl))
    {
        using (var client = new HttpClient())
        {
            var response = await client.SendAsync(request);
            response.EnsureSuccessStatusCode();
            var result = await response.Content.ReadAsStringAsync();
            return JsonConvert.DeserializeObject&lt;IList&lt;DemoData&gt;&gt;(result);
        }
    }
}</pre><p>Notice feeding in the URL from the dataserviceProfile!</p><p>Of course, we need to add this method to the IDataService interface as well:</p><pre style="font-size: 12px;">public interface IDataService : IMixedRealityExtensionService
{
    Task&lt;IList&lt;DemoData&gt;&gt; GetNames();
}</pre><h2>And now some action...</h2><p>So I created this little MonoBehaviour that actually accesses and uses the service.</p><pre style="font-size: 12px;">public class NamesReader : MonoBehaviour
{
    [SerializeField]
    private TextMeshPro _text;

    private IDataService _dataService;
    void Start()
    {
        _dataService = MixedRealityToolkit.Instance.GetService&lt;IDataService&gt;();
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha3))
        {
            LoadNames();

        }
        if (Input.GetKeyDown(KeyCode.Alpha4))
        {
            _text.text = "";
        }
    }

    private async Task LoadNames()
    {
        var names = await _dataService.GetNames();
        _text.text = string.Join(Environment.NewLine,
            names.Select(p =&gt; $"{p.FirstName} {p.LastName}"));
    }
}</pre><p>You can see how it simply gets a reference to the service in the start method. If you run this in the editor and you press "3" it will try to load the values from the service, and show them in as TextMeshPro _text (pressing "4" clears it again). The extremely spectacular result looks like this:</p><p><img width="300" height="161" style="border: 0px currentcolor; border-image: none; background-image: none;" src="https://www.schaikweb.net/blog/20190311/serviceresult.png" border="0"></p><p>Basically a direct dump from the data file on my website:</p><pre style="font-size: 12px;">[
    {
        "firstName": "Scott",
        "lastName": "Guthrie"
    },
    {
        "firstName": "Alex",
        "lastName": "Kipman"
    },
    {
        "firstName": "Scott",
        "lastName": "Hanselman"
    }
]</pre><h2>Mocking service access</h2><p>Now let's assume, for the moment, this data service is extremely expensive, slow or otherwise limited in access. Or you need to test certain edge cases but the data service does not always give them when you need them. In other words, you want to make a fake service - a <a href="https://en.wikipedia.org/wiki/Mock_object" target="_blank">mock</a> service. This, now, is very simple.</p><p>So let's build a mocking service:</p><pre>[MixedRealityExtensionService(....
public class MockDataService : BaseExtensionService, 
                               IDataService
{
    public MockDataService(IMixedRealityServiceRegistrar registrar, ....
    {
    }

    public async Task&lt;IList&lt;DemoData&gt;&gt; GetNames()
    {
        var data = new List&lt;DemoData&gt;
        {
            new DemoData {FirstName = "Joost", LastName = "van Schaik"},
            new DemoData {FirstName = "John", LastName = "Doe"},
            new DemoData {FirstName = "Kermit", LastName = "the Frog"},
        };
        await Task.Yield();
        return data;
    }
}
</pre><p>So we implement the same interface, but it does not take a DataServiceProfile configuration (although it perfectly could if I implemented the constructor). And now a second implementation version of the service appears in the drop down:</p><p><img width="500" height="285" style="border: 0px currentcolor; border-image: none; background-image: none;" src="https://www.schaikweb.net/blog/20190311/mockservice2.png" border="0"></p><p>Sow you can quickly now change a single service from a production implementation to test implementation. The mock service will show this:</p><p><img width="300" height="140" style="border: 0px currentcolor; border-image: none; background-image: none;" src="https://www.schaikweb.net/blog/20190311/mockserviceresult.png" border="0"></p><p>But what is even more cool is when you make a 'mock profile' from the RegisteredServiceProfile profile. For if you have like 20 services (and believe me, the number of services goes up pretty quickly) you can change from test to production by simply switching the profile. So I cloned the MyMixedRealityRegisteredServiceProvidersProfile itself to MockMixedRealityRegisteredServiceProvidersProfile and now, by simply switching profiles - you can change the whole extension service definition with one simple dropdown.</p><p><img width="500" height="219" style="border: 0px currentcolor; border-image: none; background-image: none;" src="https://www.schaikweb.net/blog/20190311/mockserviceprofile.png" border="0"><img width="500" height="289" style="border: 0px currentcolor; border-image: none; background-image: none;" src="https://www.schaikweb.net/blog/20190311/realserviceprofile.png" border="0"></p><h2>Conclusion</h2><p>Extension services are a really powerful feature of the MRTK2, that can be used for central access of data services - typically stuff you would use Singletons for in ye olde HoloToolkit. But using service profiles also offers a quick and easy way to switch between real and mock implementations, brings an important part of enterprise level development into the traditional - ahem - more chaotic Unity development environment.</p><p>Demo project <a href="https://github.com/LocalJoost/MKRT2DepInject.git" target="_blank">can be found here</a>.</p>
