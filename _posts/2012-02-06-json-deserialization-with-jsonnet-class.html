---
layout: post
title: 'JSON deserialization with JSON.net: class hierarchies'
date: '2012-02-06T21:53:00.001+01:00'
orgauthor: Joost van Schaik
tags:
- wpdev
- dotnetmag
- WP7NL
- Windows Phone 7
- JSON
- WP7
modified_time: '2012-07-10T15:01:38.254+02:00'
thumbnail: http://lh5.ggpht.com/-6rXh-bpNIVI/TzA9auy6AFI/AAAAAAAAHks/ZLLxqaC6xdw/s72-c/CodeScheme_thumb%25255B6%25255D.png?imgmax=800
blogger_id: tag:blogger.com,1999:blog-5295746446529817470.post-8315622686219040200
blogger_orig_url: https://dotnetbyexample.blogspot.com/2012/02/json-deserialization-with-jsonnet-class.html
---

<p>In <a href="http://localjoost.github.io/2012/01/22/json-deserialization-with-jsonnet.html" target="_blank">part 1 of this series</a> I described the basics of creating classes from a JSON string and then simply deserializing the string into a (list of) classes. That way, you don’t have all the hooplah of SOAP, but still have strongly-typed classes in your client app. But beware, there is no formal contract either, so on a beautiful morning you might start to think that either you had too much of a drink yesterday evening, or that the company providing the data feed for your app indeed has started to sell <a href="http://www.microsoft.com/windowsphone/?ocid=aff-n-we-loc--ITPRO40939&WT.mc_id=aff-n-we-loc--ITPRO40939" target="_blank">Windows Phone 7</a> devices made by Sony, with a 65” screen. </p> <p>Looking at the JSON string you now see something like this:</p><pre>[
  {
    "Brand": "Nokia","Type" : "Lumia 800", "Device" : "Phone",
    "Specs":{"Storage" : "16GB", "Memory": "512MB","Screensize" : "3.7"}
  },
  {
    "Brand": "Sony", "Type" : "KDL-65HX920","Device" : "TV",
    "Specs":{"Screensize" : "65", "FullHD" : "Yes", "ThreeD" : "Yes" }
  },  
  { "Brand": "Nokia","Type" : "Lumia 900","Device" : "Phone",
    "Specs":{"Storage" : "8GB", "Memory": "512MB","Screensize" : "4.3" }
  },
  {
    "Brand": "Samsung", "Type" : "UE55C9000","Device" : "TV",
    "Specs":{"Screensize" : "55", "FullHD" : "Yes", "ThreeD" : "Yes" }
  },  
]</pre>None of the two options mentioned before appear to be true: apparently the company has diversified. They are now selling TV's as well. Of course you could run this trough <a href="http://json2csharp.com/" target="_blank">json2csharp</a>, which will give you this:<pre>public class Specs
{
    public string Storage { get; set; }
    public string Memory { get; set; }
    public string Screensize { get; set; }
    public string FullHD { get; set; }
    public string ThreeD { get; set; }
}

public class RootObject
{
    public string Brand { get; set; }
    public string Type { get; set; }
    public string Device { get; set; }
    public Specs Specs { get; set; }
}</pre>
<p>This <em>will</em> work, but not for the purpose of what I’d like to show. We refactor the whole stuff into an object structure like this:</p>
<p><a href="http://lh3.ggpht.com/-n7Wfm-Y6890/TzA9aQylqpI/AAAAAAAAHko/MhQqRM9OFSI/s1600-h/CodeScheme%25255B10%25255D.png"><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="CodeScheme" border="0" alt="CodeScheme" src="http://lh5.ggpht.com/-6rXh-bpNIVI/TzA9auy6AFI/AAAAAAAAHks/ZLLxqaC6xdw/CodeScheme_thumb%25255B6%25255D.png?imgmax=800" width="664" height="252"></a></p>
<p>Or, in code (put into a single file for the sake of brevity)</p><pre>namespace JsonDemo
{
  public abstract class Device
  {
    public string Brand { get; set; }
    public string Type { get; set; }
  }
  
  public class Phone : Device
  {
    public PhoneSpecs Specs { get; set; }
  }
  
  public class Tv : Device
  {
    public TvSpecs Specs { get; set; }
  }
  
  public abstract class Specs
  {
    public string Screensize { get; set; }
  }
  
  public class PhoneSpecs : Specs
  {
    public string Storage { get; set; }
    public string Memory { get; set; }
  }
  
    public class TvSpecs: Specs
  {
    public string FullHd { get; set; }
    public string ThreeD { get; set; }
  }
}</pre>
<p>If you think this is a ludicrous complicated way to store such a simple data structure I think you are quite right, but a) they don’t call me a <em>Senior Software Architect</em> for nothing, making things complicated is what I am told Architects do for a living, so I try to be a Good Boy ;-) and b) this is just for the purpose of the sample, so bear with me, right? </p>
<p>If you remember the crux of part 1: it all came down to one line of code, namely:</p><pre><strong>JsonConvert.DeserializeObject&lt;List&lt;Phone&gt;&gt;(r.EventArgs.Result);</strong></pre>
<p>This method actually has a second parameter: <strong>params Newtonsoft.Json.JsonConverter[] converters</strong>, which allows you to provide your own custom converters. Making those is pretty easy, and it becomes even more easy when you use the JsonCreationConverter&lt;T&gt; class that’s floating around the internet in various permutations. I nicked it from StackOverflow <a href="http://stackoverflow.com/questions/6997502/property-based-type-resolution-in-json-net" target="_blank">here</a>. </p><pre>using System;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace JsonDemo
{
  public abstract class JsonCreationConverter&lt;T&gt; : JsonConverter
  {
    protected abstract T Create(Type objectType, JObject jsonObject);

    public override bool CanConvert(Type objectType)
    {
      return typeof(T).IsAssignableFrom(objectType);
    }

    public override object ReadJson(JsonReader reader, Type objectType, 
      object existingValue, JsonSerializer serializer)
    {
      var jsonObject = JObject.Load(reader);
      var target = Create(objectType, jsonObject);
      serializer.Populate(jsonObject.CreateReader(), target);
      return target;
    }

    public override void WriteJson(JsonWriter writer, object value, 
   JsonSerializer serializer)
    {
      throw new NotImplementedException();
    }
  }
}</pre>
<p>To make a converter, you subclass this object into a templated converter for the base class, override the “Create” method and off you go. Writing a converter for the Device/Phone/Tv hierarchy is pretty easy: you just have to check the value of the “Device” property, which you do like this:</p><pre>using System;
using Newtonsoft.Json.Linq;

namespace JsonDemo
{
  public class JsonDeviceConverter : JsonCreationConverter&lt;Device&gt;
  {
    protected override Device Create(Type objectType, JObject jsonObject)
    {
      var typeName = jsonObject["Device"].ToString();
      switch(typeName)
      {
        case "TV":
          return new Tv();
        case "Phone":
          return new Phone();
        default: return null;
      }
    }
  }
}</pre>
<p>For the Specs/PhoneSpecs/TvSpecs you do more or less the same, only now you have to check for the <em>existence</em> of certain properties, not the value. I decided that if an object has a “Storage” property it’s a PhoneSpecs, and if it has “FullHD” it’s a TVSpecs.</p><pre>using System;
using Newtonsoft.Json.Linq;

namespace JsonDemo
{
  public class JsonSpecsConverter : JsonCreationConverter&lt;Specs&gt;
  {
    protected override Specs Create(Type objectType, JObject jsonObject)
    {
      if(jsonObject["Storage"] != null)
      {
        return new PhoneSpecs();
      }

      if (jsonObject["FullHD"] != null)
      {
        return new TvSpecs();
      }

      return null;
    }
  }
}</pre>
<p>Finally, to get these converters being used by the deserializer you have to slightly modify the deserialization line:</p><pre>var deserialized = JsonConvert.DeserializeObject&lt;List&lt;Device&gt;&gt;(r.EventArgs.Result, 
  new JsonDeviceConverter(), new JsonSpecsConverter());</pre>
<p>And sure enough, if you put a breakpoint behind this line, you can place a watch on “deserialized” and see that the data structure has been deserialized in our artfully crafted class structure.</p>
<p><a href="http://lh4.ggpht.com/-jhtYhSsiVxg/TzA9bKi7iiI/AAAAAAAAHk4/lEoaqkgWtOk/s1600-h/Deserialized%25255B4%25255D.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="Deserialized" border="0" alt="Deserialized" src="http://lh5.ggpht.com/-8r-2_AvRQfs/TzA9z8Cd-1I/AAAAAAAAHlE/U_zrIMn2je0/Deserialized_thumb%25255B2%25255D.png?imgmax=800" width="665" height="338"></a></p>
<p>And that’s all there is to it. Demo solution with full code can be found <a href="http://www.schaikweb.net/dotnetbyexample/JSONDemo2.zip" target="_blank">here</a>.</p>
The third and final part of this series shows how to cache results and can be found <a href="http://dotnetbyexample.blogspot.nl/2012/05/json-deserialization-with-jsonnet.html" target="_blank">here</a>