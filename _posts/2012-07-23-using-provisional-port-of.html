---
layout: post
title: Using a provisional WinRT port of SilverlightSerializer to store state in MVVMLight
  ViewModels
date: '2012-07-23T21:47:00.001+02:00'
orgauthor: Joost van Schaik
tags:
- dotnetmag
- C#
- Windows 8
- WinRt
- MVVM Light
- Win8nl
modified_time: '2012-07-24T09:58:07.898+02:00'
blogger_id: tag:blogger.com,1999:blog-5295746446529817470.post-6128988336495225544
blogger_orig_url: https://dotnetbyexample.blogspot.com/2012/07/using-provisional-port-of.html
---

<p>Over 1.5 years ago I <a href="http://dotnetbyexample.blogspot.nl/2011/01/tombstoning-mvvmlight-viewmodels-with.html" target="_blank">showed</a> how to store your <a href="http://www.microsoft.com/windowsphone/?ocid=aff-n-we-loc--ITPRO40939&amp;WT.mc_id=aff-n-we-loc--ITPRO40939" target="_blank">Windows Phone</a> application state (‘tombstoning’) using SilverlightSerializer by <a href="http://twitter.com/mike_talbot">Mike Talbot</a>. In my quest to leverage hard-won Windows Phones skills to be usable in <a href="http://windows.microsoft.com/en-US/windows-8/release-preview?ocid=aff-n-we-loc--ITPRO40939&amp;WT.mc_id=aff-n-we-loc--ITPRO40939" target="_blank">Windows 8</a> I made a provisional port of SilverlightSerializer 1 to <a href="http://msdn.microsoft.com/en-us/library/windows/apps/br211377.aspx?ocid=aff-n-we-loc--ITPRO40939&amp;WT.mc_id=aff-n-we-loc--ITPRO40939">WinRT</a>. That is, in C#.</p> <p>Since my win8nl library port is a bit behind, I’ve stuck the class in a simple project that you can download <a href="http://www.schaikweb.net/dotnetbyexample/Win8nl.Utilities.zip" target="_blank">here</a>. </p> <p>Usage is as follows: in App.xaml.cs, you define two methods: SaveState and RestoreState:</p><pre>private async void SaveState()
{
  var file = 
    await ApplicationData.Current.LocalFolder.CreateFileAsync(
      "AppState.dat", CreationCollisionOption.ReplaceExisting);

  using (var fileStream = await file.OpenStreamForWriteAsync())
  {
    SilverlightSerializer.Serialize(MainViewModel.Instance, fileStream);
  }
}</pre>
<p>Pretty simple: when the state needs to be saved, create a file, get a stream, and let SilverlightSerializer do its magic. As for RestoreState:</p><pre>private async Task RestoreState()
{
  try
  {
    var files = await ApplicationData.Current.LocalFolder.GetFilesAsync();
    var dataFile = files.FirstOrDefault(p =&gt; p.Name == "AppState.dat");
    if (dataFile != null)
    {
      using (var fileStream = await dataFile.OpenSequentialReadAsync())
      {
        MainViewModel.Instance = 
          SilverlightSerializer.Deserialize(fileStream.AsStreamForRead()) 
            as MainViewModel;
      }
    }
  }
  finally
  {
    if (MainViewModel.Instance == null) MainViewModel.CreateNew();
    MainViewModel.Instance.Start();
  }
}</pre>
<p>This basically tries to deserialize a viewmodel from a file “AppState.dat”. If that fails, it creates a new MainViewModel, and starts it. The whole idea behind this is described <a href="http://dotnetbyexample.blogspot.nl/2011/01/tombstoning-mvvmlight-viewmodels-with.html" target="_blank">in the original Windows Phone 7 post</a>, so I encourage you to read that if you have no idea what I am doing here.</p>
<p>Now the important bit is <em>when </em>to call this methods. If you think the most logical place for RestoreState is in OnLaunched, you are right. The first few lines of my OnLaunced method in App.xaml.cs look like this in my app:</p><pre>if (args.PreviousExecutionState == ApplicationExecutionState.Running)
{
  Window.Current.Activate();
  return;
}
else
{
  await RestoreState();
}</pre>
<p>Now the most logical place to call SaveState is of course OnSuspending, and we are done, right? </p>
<p><em><strong>Wrong</strong></em>.</p>
<p>To my own utter surprise, yesterday, after a long debugging session, I found a weird edge scenario. I asserted the following: if a user <em>closes</em> an app by the “<a href="http://www.youtube.com/watch?v=29kfGnrDjx0" target="_blank">Swipe Down gesture</a>”, it takes about 10 seconds (on my Samsung Slate 7) before OnSuspending is called. When the user restarts the app <em>within</em> those 10 seconds from the start screen, the state is not stored yet, or too late – in any case it is not yet available to the (yet again) starting app. So you don’t get the <em>last</em> state, but the state <em>before that</em>, as I shamefully discovered when I proudly showed my state save method to an Application Excellence Lab Microsoftie :( </p>
<p>Don’t get me wrong – the actual time SaveState runs in my app is about 0.047 seconds. It’s lightning fast – just like the original SilverlightSerializer. But the time between user closing the app and the actual state save being fired up was killing my state.</p>
<p>The solution to this is very simple: when the user closes the app, Window.Current.VisibilityChanged is fired. Not like after a few seconds, but <em>instantly. </em>So add and event listener to that at the bottom of OnLaunched, that calls SaveState , like this:</p><pre> Window.Current.VisibilityChanged += (o, e) =&gt; {if (!e.Visible) SaveState();};</pre>
<p>Basically: if the visibility of the current windows changes to invisible, write the state. Maybe you write app state too often (for example because the user temporarily puts it in the background, then VisibilityChanged is fired as well) but at least you circumvent the problem I ran into. Since state writing takes very little time, better often than not at all, I’d say.</p>
<p>And in OnSuspending? Well, you could call SaveState from there, too. That’s useful when your app does something in the background and it’s state changes even when the users has put it in the background. Then, when the OS kicks it into suspension because it runs out of memory, the state is saved too.</p>
<p><strong>Caveat emptor</strong>: I kinda roughly hacked Mike Talbots work to operate in the WinRT world. The current state is ‘works for me’. I commented out the whole section about Dictionary support, so I suppose that does not work. My ultimate goal is to convert SilverlightSerializer 2, but that was too big a bone to chew in a short time. It serves my ported game Catch’em Birds fine. I hope to get it finished soon.</p>