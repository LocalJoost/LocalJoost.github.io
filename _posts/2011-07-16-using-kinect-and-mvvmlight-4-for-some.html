---
layout: post
title: Using Kinect and MVVMLight 4 for some basic Google Maps manipulation
date: '2011-07-16T13:50:00.002+02:00'
author: Joost van Schaik
tags:
- Kinect
- dotnetmag
- MVVM
- Natural User Interfaces
- NUI
- WPF
- XAML
- MVVM Light
modified_time: '2011-07-18T15:31:28.268+02:00'
thumbnail: http://lh3.ggpht.com/-sFS0RrNTqLU/TiF60Nt9FaI/AAAAAAAAGo8/M6ITyBkPk7A/s72-c/rightzoomin_thumb15.png?imgmax=800
blogger_id: tag:blogger.com,1999:blog-5295746446529817470.post-3155896843536668226
blogger_orig_url: https://dotnetbyexample.blogspot.com/2011/07/using-kinect-and-mvvmlight-4-for-some.html
---

<p>Being a new tech junkie, I of course wanted to try the waters when the <a href="http://research.microsoft.com/en-us/um/redmond/projects/kinectsdk/" target="_blank">Kinect beta SDK</a> was released on June 16, 2011. I thought it best to avoid domestic trouble and let the Kinect my wife bought back in December sit nicely connected to the XBox360 downstairs, and ordered a second Kinect – which just happened to be on sale for only €99.</p>  <p><font size="4">The global idea</font></p>  <p>I wanted to create a simple application that allows you to both pan and zoom on a standard Google Maps web site, using hand gestures and some speech commands. I wanted to show visual feedback projected over the browser, like moving hands and stuff like that. Because I wanted to re-use some of my hard-won <a href="http://www.microsoft.com/windowsphone/en-us/default.aspx" target="_blank">Windows Phone 7</a> knowledge, I wanted to use MVVM as well. So enter <a href="http://mvvmlight.codeplex.com/" target="_blank">MVVMLight</a> and while I was at it, version 4 too. The SDK is not usable from Silverlight, so the choice fell logically on Windows Presentation Foundation (WPF) to host a browser and see how things went from there. The result is below. It’s pretty crude and the user experience leaves much to be desired, but it’s a nice start. I will explain what I’ve done and why, and as usual include the <a href="http://www.schaikweb.net/dotnetbyexample/mapcontroller.zip" target="_blank">whole sample application</a>.</p>  <p><font size="4">Basic operation</font></p>  <p>When the application opens up, it shows Google Maps in a full screen browser, and pretty much nothing else. To enable a demo I am planning to give, the Kinect is not immediately initialized. Forgive this old Trekkie - I could not resist. For years I’ve envied Kirk and Picard for being able to command their computer by talking to it. To get the application to start tracking your hands, you have to say “<em>Kinect engage</em>”. :-)</p>  <p>If Kinect understands your command, it will show the command to the left. If you move your hands, to yellow semi-transparent hand symbols should appear. If you move your hands from left to right they follow you – moving them forward will make them smaller, moving them backward bigger.</p>  <p>If you say “<em>Kinect track”</em>&#160; you can do the following:</p>  <p><a href="http://lh3.ggpht.com/-hoQkZoonry4/TiF6ztizwQI/AAAAAAAAGo4/rmTdoAG9ae4/s1600-h/rightzoomin21.png"><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: left; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="rightzoomin" border="0" alt="rightzoomin" align="left" src="http://lh3.ggpht.com/-sFS0RrNTqLU/TiF60Nt9FaI/AAAAAAAAGo8/M6ITyBkPk7A/rightzoomin_thumb15.png?imgmax=800" width="22" height="31" /></a>If you hold your <em>left </em>hand <em>closer</em> to your body than your right hand by some 20 cm, it will zoom <em>in</em> on the location of your <em>right</em> hand (green “plus” symbol on the right hand symbol).&#160; </p>  <p><a href="http://lh4.ggpht.com/-LCTGpy2OcDs/TiF60lZgR0I/AAAAAAAAGpA/2galnCDZ2EY/s1600-h/rightzoomout21.png"><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: left; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="rightzoomout" border="0" alt="rightzoomout" align="left" src="http://lh6.ggpht.com/-brKw96YJO1Q/TiF603zRAJI/AAAAAAAAGpE/1HjJ8ax3UlI/rightzoomout_thumb13.png?imgmax=800" width="22" height="31" /></a>If you hold your <em>left </em>hand <em>further </em>from your body than your right hand by some 20 cm, it will <em>zoom</em> out on the location of your <em>right</em> hand (red “minus” symbol on the right hand symbol”) </p>  <p><a href="http://lh6.ggpht.com/-aP9UPp3Pf3w/TiF61WjPy6I/AAAAAAAAGpI/16b9MCUQPb8/s1600-h/rightpan4.png"><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: left; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="rightpan" border="0" alt="rightpan" align="left" src="http://lh5.ggpht.com/-cqxG0uByp0g/TiF61xVklNI/AAAAAAAAGpM/8sYO7IF1lhM/rightpan_thumb2.png?imgmax=800" width="22" height="31" /></a>If you stretch out both arms and then move your hands, you can pan the map (blue circle with cross will appear on both of the hand symbols). </p>  <p>Below is a partial screenshot showing Kinect zooming in on Ontario.</p>  <p><a href="http://lh5.ggpht.com/-p6kdmcANa-I/TiF63Y0GMGI/AAAAAAAAGpQ/fe0BkuEJZFU/s1600-h/kinecttrack6.png"><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="kinecttrack" border="0" alt="kinecttrack" src="http://lh4.ggpht.com/-y8wiujp3zGY/TiF64KGeZNI/AAAAAAAAGpU/uWd5DW_pGfs/kinecttrack_thumb2.png?imgmax=800" width="628" height="287" /></a></p>  <p>Miscellaneous voice commands:</p>  <ul>   <li>“<em>Kinect stop tracking</em>” will keep following your hands but disable zoom and pan until you say “Kinect track” again </li>    <li>“<em>Kinect video on</em>” will show what the Kinect video cam is seeing on the top left of the screen </li>    <li>“<em>Kinect video off</em>” will hide video again (you might want to do this as it’s heavy on performance) </li>    <li>“<em>Kinect shutdown</em>” will exit the application </li> </ul>  <p>&#160;</p>  <div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:5737277B-5D6D-4f48-ABFC-DD9C333F4C5D:f988b7f7-aced-4bcf-84b8-6d379b367e2e" class="wlWriterEditableSmartContent"><div id="d6188042-eaf2-4138-b31c-5296746532d2" style="margin: 0px; padding: 0px; display: inline;"><div><a href="http://www.youtube.com/watch?v=Bsec6xF_rNg" target="_new"><img src="http://lh6.ggpht.com/-R_9qhgRp7vM/TiF64u62BQI/AAAAAAAAGpo/JDEqEQxwCzg/video845bbcf8a951%25255B30%25255D.jpg?imgmax=800" style="border-style: none" galleryimg="no" onload="var downlevelDiv = document.getElementById('d6188042-eaf2-4138-b31c-5296746532d2'); downlevelDiv.innerHTML = &quot;&lt;div&gt;&lt;object width=\&quot;448\&quot; height=\&quot;277\&quot;&gt;&lt;param name=\&quot;movie\&quot; value=\&quot;http://www.youtube.com/v/Bsec6xF_rNg?hl=en&amp;hd=1\&quot;&gt;&lt;\/param&gt;&lt;embed src=\&quot;http://www.youtube.com/v/Bsec6xF_rNg?hl=en&amp;hd=1\&quot; type=\&quot;application/x-shockwave-flash\&quot; width=\&quot;448\&quot; height=\&quot;277\&quot;&gt;&lt;\/embed&gt;&lt;\/object&gt;&lt;\/div&gt;&quot;;" alt=""></a></div></div><div style="width:448px;clear:both;font-size:.8em">The application in action. Since my computer choked on running both Kinect and a screen recorder I actually did this the old fashioned way using a video camera recording the screen ;)</div></div>  <p><font size="4">Setting the stage</font></p>  <p>To get this sample to work, you need quite a lot of stuff, both hard- and software. First, of course, you will need a Kinect sensor. Be aware you cannot use a Kinect that comes with an XBox360s – that only has the proprietary orange Kinect connector that may look like and USB connector, but most certainly is not. You will need a <a href="http://www.xbox.com/en-US/Xbox360/Accessories/Kinect/kinectforxbox360" target="_blank">retail Kinect for Xbox360 sensor</a>, which includes special USB/power cabling – that will connect to your PC’s ‘ordinary’ USB port</p>  <p>A word to the wise: if you have a desk top PC, connect Kinect to a back USB port and never, ever use an USB extension cable. Unless you are entertained by very frequent <a href="http://en.wikipedia.org/wiki/Blue_Screen_of_Death" target="_blank">BSOD</a>’s. I learned it the hard way - make sure you don’t.</p>  <p>Then you need quite some stuff to download and install:</p>  <ul>   <li>The Kinect SDK from the <a href="http://research.microsoft.com/en-us/um/redmond/projects/kinectsdk/download.aspx" target="_blank">beta SDK page</a> </li>    <li><a href="http://www.microsoft.com/downloads/en/details.aspx?displaylang=en&amp;FamilyID=3021d52b-514e-41d3-ad02-438a3ba730ba">Microsoft DirectX® SDK - June 2010</a> </li>    <li><a href="http://www.microsoft.com/downloads/en/details.aspx?FamilyID=bb0f72cb-b86b-46d1-bf06-665895a313c7">Microsoft Speech Platform Runtime, version 10.2</a> (x86 edition) </li>    <li><a href="http://www.microsoft.com/downloads/en/details.aspx?FamilyID=1b1604d3-4f66-4241-9a21-90a294a5c9a4&amp;displaylang=en">Microsoft Speech Platform - Software Development Kit, version 10.2 </a>(x86 edition) </li>    <li><a href="http://go.microsoft.com/fwlink/?LinkId=220942">Kinect for Windows Runtime Language Pack, version 0.9</a> </li> </ul>  <p>I would also recommend very much installing the <a href="http://kinectcontrib.codeplex.com/" target="_blank">Kinect project templates for Visual Studio 2010</a> by the brilliant <a href="http://twitter.com/#!/DennisCode" target="_blank">Dennis Delimarsky</a>. I started out by using his Kinect Skeleton template application.</p>  <p><font size="4">MVVMLight 4</font></p>  <p>MVVMLight 4 does not have a binary release yet, as far as I understand, so I pulled the <a href="http://mvvmlight.codeplex.com/" target="_blank">sources from CodePlex</a>, compiled the whole stuff and took the following parts:</p>  <ul>   <li>GalaSoft.MvvmLight.WPF4.dll </li>    <li>GalaSoft.MvvmLight.Extras.WPF4.dll </li>    <li>Microsoft.Practices.ServiceLocation.dll </li>    <li>System.Windows.Interactivity.dll </li> </ul>  <p>After building you will find the first file in <em>GalaSoft.MvvmLight\GalaSoft.MvvmLight (NET4)\bin\Release</em>, the others in <em>GalaSoft.MvvmLight\GalaSoft.MvvmLight.Extras (NET4)\bin\Release</em></p>  <p><font size="4">Coding4Fun Kinect Toolkit</font> </p>  <p>I used only a tiny bit of it, and still have to investigate what it can do, but you can find it here on <a href="http://c4fkinect.codeplex.com/" target="_blank">CodePlex</a>.</p>  <p><font size="4">Setting up the project</font></p>  <p><a href="http://lh4.ggpht.com/-oWrD_4eFqA4/TiF65ASWIJI/AAAAAAAAGpc/RXq-jBBPsGg/s1600-h/KinectSolution3.png"><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: right; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="KinectSolution" border="0" alt="KinectSolution" align="right" src="http://lh6.ggpht.com/-aHho6aB-9c8/TiF659j9qtI/AAAAAAAAGpg/iG92-ZmhLlQ/KinectSolution_thumb1.png?imgmax=800" width="252" height="470" /></a>A good programmer is a lazy programmer, so I just selected Dennis Delimarsky’s KinectSkeletonApplication template (you will find it under Visual C#\Windows\Kinect). That creates a nice basic WPF-based Kinect skeleton tracking application that <em>works out of the box</em> – it projects the video image Kinect sees, and tracks your hands with two red circles. This actually got me off the ground in no time at all, so kudos and thanks to you, Dennis! </p>  <p>After peeking in Dennis’ code I cleaned the MainPage.xaml and MainPage.xml.cs. Then I added the following references:</p>  <ul>   <li>Coding4Fun.Kinect.Wpf.dll </li>    <li>GalaSoft.MvvmLight.WPF4.dll </li>    <li>GalaSoft.MvvmLight.Extras.WPF4.dll </li>    <li>Microsoft.Practices.ServiceLocation.dll </li>    <li>System.Windows.Interactivity.dll </li>    <li>Microsoft.Speech.dll (on my computer it’s sitting in <em>C:\Program Files\Microsoft Speech Platform SDK\Assembly</em>) </li> </ul>  <p>As usual, I put assemblies like this in a solution folder called “Binaries” first, to ensure they become part of the solution itself. The net result is displayed right:</p>  <p><font size="4">Main viewmodel</font></p>  <p>MainViewModel is <em>very</em> simple and is basically nothing more than a Locater:</p>  <pre>using GalaSoft.MvvmLight;

namespace MapController.ViewModel
{
  public class MainViewModel : ViewModelBase
  {
    private static PoseViewModel _poseViewModelInstance;
    public static PoseViewModel PoseViewModel
    {
      get { return _poseViewModelInstance ?? 
        (_poseViewModelInstance = new PoseViewModel()); }
    }
  }
}</pre>

<p>This is a pretty standard pattern that makes sure that now matter how much MainViewModels you create by XAML instantiation, there will be one and only one PoseViewModel.</p>

<p><font size="4">The Pose viewmodel</font></p>

<p>PoseViewModel is currently a kind of God class and probably should be broken up should this become a real application one day. This is where most of the Kinect stuff lives. And it’s remarkably small for all the things it actually does. It starts out like this:</p>

<pre>using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows;
using Coding4Fun.Kinect.Wpf;
using GalaSoft.MvvmLight;
using GalaSoft.MvvmLight.Messaging;
using MapController.Messages;
using Microsoft.Research.Kinect.Nui;
using Vector = Microsoft.Research.Kinect.Nui.Vector;

namespace MapController.ViewModel
{
  public class PoseViewModel : ViewModelBase, IDisposable
  {
    private Runtime _runtime;
    private const int Samples = 2;
    private const string DefaultleftHand = &quot;Resources/lefthand.png&quot;;
    private const string DefaultrightHand = &quot;Resources/righthand.png&quot;;

    private readonly List&lt;SkeletonData&gt; _skeletons;

    public PoseViewModel()
    {
      if (!IsInDesignMode)
      {
        _leftHandImage = DefaultleftHand;
        _rightHandImage = DefaultrightHand;
        _skeletons = new List&lt;SkeletonData&gt;();
        _runtime = new Runtime();
        _runtime.SkeletonFrameReady += RuntimeSkeletonFrameReady;
        _runtime.VideoFrameReady += RuntimeVideoFrameReady;
        _runtime.Initialize(
          RuntimeOptions.UseSkeletalTracking | RuntimeOptions.UseColor);
        _runtime.VideoStream.Open(ImageStreamType.Video, 
          2, ImageResolution.Resolution640x480, ImageType.Color);
        Messenger.Default.Register&lt;CommandMessage&gt;(this, ProcessSpeechCommand);
        SpeechController.Initialize();
      }
    }

    void RuntimeVideoFrameReady(object sender, ImageFrameReadyEventArgs e)
    {
      if (ShowVideo)
      {
        Messenger.Default.Send(new VideoFrameMessage {Image = e.ImageFrame.Image});
      }
    }
  }
}</pre>

<p>Important to note is the Vector alias on top – there is also a System.Windows.Vector and you sure don’t want to use that one. This basically initializes the Kinect “Runtime”, instructs it to use skeleton and video tracking and defines callbacks for that. The SpeechController – I will get to that later – is initialized as well. Note the <em>_skeletons </em>list – I use that to take the average of a more than one (actually two) skeletons to make the hand tracking a bit more stable.</p>

<p>Note also the callback “RuntimeVideoFrameReady”- it just shuttles off a frame in a message. A behavior - the DisplayVideoBehavior - will take care of that. I tried to do this with data binding; it works, but gave a less than desirable performance, to put it mildly. </p>

<p>The ViewModel has 12 properties, which all follow the new MVVMLight 4 syntax:</p>

<pre>private Vector _lefthandPosition;
public Vector LeftHandPosition
{
  get { return _lefthandPosition; }
  set
  {
    if (!_lefthandPosition.Equals(value))
    {
       _lefthandPosition = value;
       RaisePropertyChanged(() =&gt; LeftHandPosition);
    }
  }
}</pre>

<p>To prevent this blog post challenging <a href="http://en.wikipedia.org/wiki/War_and_Peace" target="_blank">Tolstoy’s &quot;War and Peace'”</a> for length I will only name the rest by name and type: </p>

<ul>
  <li>Vector RightHandPosition </li>

  <li>double LeftHandScale </li>

  <li>double RightHandScale </li>

  <li>Visibility HandVisibility </li>

  <li>string LeftHandImage </li>

  <li>string RightHandImage </li>

  <li>bool IsInitialized </li>

  <li>bool IsTracking </li>

  <li>bool ShowVideo </li>

  <li>string LastCommand </li>
</ul>

<p>Except for this one, since is does something more – it changes the images for the hands, if neccesary:</p>

<pre>private bool _isPanning;
public bool IsPanning
{
  get { return _isPanning; }
  set
  {
    if (_isPanning != value)
    {
      _isPanning = value;
      LeftHandImage = _isPanning ? &quot;Resources/leftpan.png&quot; : DefaultleftHand;
      RightHandImage = _isPanning ? &quot;Resources/rightpan.png&quot; : DefaultrightHand;
      RaisePropertyChanged(() =&gt; IsPanning);
    }
  }
}</pre>

<p>The actual skeleton and pose processing code is surprisingly simple, then:</p>

<pre>void RuntimeSkeletonFrameReady(object sender, SkeletonFrameReadyEventArgs e)
{
  if (IsInitialized)
  {
    var skeletonSet = e.SkeletonFrame;

    var data = (from s in skeletonSet.Skeletons
                where s.TrackingState == SkeletonTrackingState.Tracked
                select s).FirstOrDefault();

    lock (new object())
    {
      _skeletons.Add(data);
    }
    if (_skeletons.Count &lt; Samples)
    {
      return;
    }
    lock (new object())
    {
      LeftHandPosition = 
        ScaleJoint(_skeletons.Average(JointID.HandLeft)).Position;
      RightHandPosition = 
        ScaleJoint(_skeletons.Average(JointID.HandRight)).Position;
      var spinePosition = 
        ScaleJoint(_skeletons.Average(JointID.Spine)).Position;
      _skeletons.Clear();

      LeftHandScale = RelativePositionToScale(spinePosition, LeftHandPosition);
      RightHandScale = RelativePositionToScale(spinePosition, RightHandPosition);
      HandVisibility = Visibility.Visible;

      if (IsTracking)
      {
        // Both arms stretched: initiate pan
        IsPanning = ((spinePosition.Z - LeftHandPosition.Z) &gt; 0.5 &amp;&amp; 
                    (spinePosition.Z - RightHandPosition.Z) &gt; 0.5);

        if (!IsPanning)
        {
          // Send a zoom in/out message depending on the hand's relative positions 
          var handDist = (LeftHandPosition.Z - RightHandPosition.Z);
          if (handDist &gt; 0.2)
          {
            // left hand pulled back: zoom in
            Messenger.Default.Send(new ZoomMessage 
             { X = RightHandPosition.X, Y = RightHandPosition.Y, Zoom = 1 });

            RightHandImage = &quot;Resources/rightzoomin.png&quot;;
          }
          else if (handDist &lt; -0.2)
          {
            // left hand pushed forward back: zoom out
            Messenger.Default.Send(new ZoomMessage 
              { X = RightHandPosition.X, Y = RightHandPosition.Y, Zoom = -1 });
            RightHandImage = &quot;Resources/rightzoomout.png&quot;;
          }
          else
          {
            RightHandImage = DefaultrightHand;
          }
        }
      }
      else
      {
        IsPanning = false;
      }
    }
  }
}</pre>

<p>This is really the core of the whole pose recognition performed by this application. The method basically takes a skeleton and puts it in a list. If the desired number of samples are obtained, the average of joints is calculated and scale to the screen. Then it checks if both hands are 50 cm or more before the main body (‘Spine’) – this is assumed to be a panning pose. If that’s not recognized, the method tries to detect if one hand is more than 20 cm before another, so it should initiate a zoom action – this is done by sending a ZoomMessage. If that’s so, the right hand’s image is changed accordingly. The ZoomMessage is so simple I will omit it's source here</p>

<p>This uses a few other methods:</p>

<pre>/// &lt;summary&gt;
/// Convert a relative position to a scale
/// &lt;/summary&gt;
/// &lt;param name=&quot;spinePos&quot;&gt;&lt;/param&gt;
/// &lt;param name=&quot;handPos&quot;&gt;&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
private double RelativePositionToScale( Vector spinePos, Vector handPos )
{
  // 30 cm before the chest is 'zero position'
  return 1 - ((spinePos.Z - handPos.Z - 0.3) * 1.8);
}

/// &lt;summary&gt;
/// Scale a joint
/// &lt;/summary&gt;
/// &lt;param name=&quot;joint&quot;&gt;&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
private Joint ScaleJoint(Joint joint)
{
  return joint.ScaleTo(
    (int)SystemParameters.PrimaryScreenWidth, 
    (int)(SystemParameters.PrimaryScreenHeight), 0.5f, 0.5f);
}</pre>
Both speak pretty much for themselves. The Joint.ScaleTo extension method is coming from Coding4Fun. The ‘Average’ extension methods are my own, and are defined in a separate class: 

<pre>using System.Collections.Generic;
using System.Linq;
using Microsoft.Research.Kinect.Nui;
using Vector = Microsoft.Research.Kinect.Nui.Vector;

namespace MapController
{
  public static class KinectExtensions
  {
    /// &lt;summary&gt;
    /// Calculates the average Vectors of a any number of Vectors
    /// &lt;/summary&gt;
    public static Vector Average(this IEnumerable&lt;Vector&gt; vectors)
    {
      return new Vector {
        X = vectors.Select(p =&gt; p.X).Average(),
        Y = vectors.Select(p =&gt; p.Y).Average(),
        Z = vectors.Select(p =&gt; p.Z).Average(),
        W = vectors.Select(p =&gt; p.W).Average(),
      };
    }

    /// &lt;summary&gt;
    /// Calculates the average of a specific Joint in a number of vectors
    /// &lt;/summary&gt;
    public static Joint Average( this IEnumerable&lt;SkeletonData&gt; data, 
      JointID joint)
    {
      return new Joint
      {
        Position = data.Select(skeleton =&gt; 
          skeleton.Joints[joint].Position).Average()
      };
    }
  }
}</pre>

<p>Now let's have a look at the GUI. </p>

<p><font size="4">Transparent overlay window</font></p>

<p>WPF poses some unique challenges, one of those being the fact that no WPF objects can be drawn on top of Win32 objects – like, for instance, a WebBrowser control. To circumvent this I created <em>second child window</em> – full screen, like the first window, but Transparent. So I added KinectOverlay.xaml. This window is launched from MainWindow.xaml.cs as a child window like this: </p>

<pre>namespace MapController
{
  public partial class MainWindow : Window
  {
    public MainWindow()
    {
      InitializeComponent();
      Loaded += MainWindowLoaded;
    }

    void MainWindowLoaded(object sender, RoutedEventArgs e)
    {
      var w = new KinectOverlay {Owner = this};
      w.Show();
    }
  }
}</pre>

<p><font size="4">MainWindow</font></p>

<p>There's not much in there, actually. Just a browser and some behaviors. </p>

<pre>&lt;Window xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; 
    xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; 
    xmlns:i=&quot;http://schemas.microsoft.com/expression/2010/interactivity&quot; 
    xmlns:MapController_Behaviors=&quot;clr-namespace:MapController.Behaviors&quot; 
    WindowStyle=&quot;None&quot; WindowState=&quot;Maximized&quot; 
    x:Class=&quot;MapController.MainWindow&quot; Height=&quot;355&quot; Width=&quot;611&quot; 
    ShowInTaskbar=&quot;True&quot; AllowsTransparency=&quot;False&quot;
    DataContext=&quot;{Binding PoseViewModel, Source={StaticResource MainViewModel}}&quot;&gt;
  &lt;i:Interaction.Behaviors&gt;
    &lt;MapController_Behaviors:ZoomBehavior/&gt;
    &lt;MapController_Behaviors:PanBehavior 
        RightHandPosition=&quot;{Binding RightHandPosition, Mode=TwoWay}&quot; 
        LeftHandPosition=&quot;{Binding LeftHandPosition, Mode=TwoWay}&quot;
        IsPanning=&quot;{Binding IsPanning, Mode=TwoWay}&quot;&gt;
    &lt;/MapController_Behaviors:PanBehavior&gt;
  &lt;/i:Interaction.Behaviors&gt;
   &lt;Grid x:Name=&quot;Grid&quot;&gt;
     &lt;WebBrowser x:Name=&quot;Browser&quot; Source=&quot;http://maps.google.com&quot; /&gt;
   &lt;/Grid&gt;
&lt;/Window&gt;</pre>

<p>As you can see, the actual zoom and pan actions are performed by two behaviors – named “Zoombehavior” and “PanBehavior”. Windows Phone 7 developers, please take note of the fact that WPF allows you to directly bind to behavior dependency properties (this will be possible in the next Windows Phone 7 release as well, since that runs Silverlight 4-ish). Here we come down to the dirty parts of the solution, for the actual map manipulation is performed by simulating mouse position and buttondowns for dragging, and mouse wheel rotations for zoomin in and out. If you are interested in the actual innards of these things, please refer to the <a href="http://www.schaikweb.net/dotnetbyexample/mapcontroller.zip" target="_blank">sample solution</a>. Below is just a short description</p>

<ul>
  <li>The Zoombehavior just waits for a ZoomMessage – and then simulates a zoom in or out by moving the mouse cursor to the position of the right hand, and then simulating a scroll wheel rotation by one position. It only accepts one zoom per 2 seconds to prevent zooming in or out at an uncontrollable rate. </li>

  <li>The PanBehavior has three dependency properties bound to both hand positions, and IsPanning. If the model says its panning, it calculates the point between left and right hand, and uses that as a dragging origin. </li>
</ul>

<p>Both use a NativeWrapper static class that uses some Win32 api calls – courtesy of <a href="http://www.pinvoke.net/" target="_blank">pinvoke.net</a></p>

<p><font size="4">KinectOverlay</font></p>

<p>Also pretty simple:&#160; A Grid containing a Canvas, which contains standard behavior, and then three images and a text: left hand, right hand, video output, and text place holder to show the last command – all bound to the PoseViewModel. Don’t you just love the power of XAML? ;-)</p>

<pre style="font-size: 11px">&lt;Window
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
    xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;  
    xmlns:i=&quot;http://schemas.microsoft.com/expression/2010/interactivity&quot; 
    xmlns:ei=&quot;http://schemas.microsoft.com/expression/2010/interactions&quot; 
    xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; 
    xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; 
    xmlns:MapController_Behaviors=&quot;clr-namespace:MapController.Behaviors&quot; 
    mc:Ignorable=&quot;d&quot; x:Class=&quot;MapController.KinectOverlay&quot;
    Title=&quot;KinectOverlay&quot; Height=&quot;300&quot; Width=&quot;300&quot; WindowStyle=&quot;None&quot; 
    WindowState=&quot;Maximized&quot; Background=&quot;Transparent&quot; AllowsTransparency=&quot;True&quot;&gt;
  &lt;Grid&gt;
  &lt;i:Interaction.Behaviors&gt;
    &lt;ei:FluidMoveBehavior AppliesTo=&quot;Children&quot; Duration=&quot;0:0:0.5&quot;&gt;
    &lt;ei:FluidMoveBehavior.EaseX&gt;
      &lt;SineEase EasingMode=&quot;EaseInOut&quot;/&gt;
    &lt;/ei:FluidMoveBehavior.EaseX&gt;
    &lt;ei:FluidMoveBehavior.EaseY&gt;
      &lt;SineEase EasingMode=&quot;EaseInOut&quot;/&gt;
    &lt;/ei:FluidMoveBehavior.EaseY&gt;
    &lt;/ei:FluidMoveBehavior&gt;
  &lt;/i:Interaction.Behaviors&gt;
  &lt;Canvas Background=&quot;Transparent&quot; 
  DataContext=&quot;{Binding PoseViewModel, Source={StaticResource MainViewModel}}&quot;&gt;

    &lt;!-- Left hand --&gt;
    &lt;Image Source=&quot;{Binding LeftHandImage}&quot; x:Name=&quot;leftHand&quot; Stretch=&quot;Fill&quot;
       Canvas.Left=&quot;{Binding LeftHandPosition.X, Mode=TwoWay}&quot;  
       Canvas.Top=&quot;{Binding LeftHandPosition.Y, Mode=TwoWay}&quot;
       Visibility=&quot;{Binding HandVisibility}&quot; Opacity=&quot;0.75&quot;
       Height=&quot;118&quot; Width=&quot;80&quot; RenderTransformOrigin=&quot;0.5,0.5&quot;&gt;
    &lt;Image.RenderTransform&gt;
      &lt;TransformGroup&gt;
      &lt;ScaleTransform ScaleX=&quot;{Binding LeftHandScale}&quot; 
        ScaleY=&quot;{Binding LeftHandScale}&quot;/&gt;
      &lt;SkewTransform/&gt;
      &lt;RotateTransform/&gt;
      &lt;TranslateTransform X=&quot;-40&quot; Y=&quot;-59&quot;/&gt;
      &lt;/TransformGroup&gt;
    &lt;/Image.RenderTransform&gt;
    &lt;/Image&gt;

    &lt;!-- Right hand --&gt;
    &lt;Image x:Name=&quot;righthand&quot; Source=&quot;{Binding RightHandImage}&quot; Stretch=&quot;Fill&quot;
       Canvas.Left=&quot;{Binding RightHandPosition.X, Mode=TwoWay}&quot;  
       Canvas.Top=&quot;{Binding RightHandPosition.Y, Mode=TwoWay}&quot;
       Visibility=&quot;{Binding HandVisibility}&quot; Opacity=&quot;0.75&quot;
       Height=&quot;118&quot; Width=&quot;80&quot; RenderTransformOrigin=&quot;0.5,0.5&quot;&gt;
    &lt;Image.RenderTransform&gt;
      &lt;TransformGroup&gt;
      &lt;ScaleTransform ScaleX=&quot;{Binding RightHandScale}&quot; 
        ScaleY=&quot;{Binding RightHandScale}&quot;/&gt;
      &lt;SkewTransform/&gt;
      &lt;RotateTransform/&gt;
      &lt;TranslateTransform X=&quot;-40&quot; Y=&quot;-59&quot;/&gt;
      &lt;/TransformGroup&gt;
    &lt;/Image.RenderTransform&gt;
    &lt;/Image&gt;

    &lt;!-- Video --&gt;
    &lt;Image Canvas.Left=&quot;0&quot; Canvas.Top=&quot;100&quot; Width =&quot;360&quot; 
     Visibility=&quot;{Binding ShowVideo, Converter={StaticResource booleanToVisibilityConverter}}&quot;&gt;
    &lt;i:Interaction.Behaviors&gt;
      &lt;MapController_Behaviors:DisplayVideoBehavior/&gt;
    &lt;/i:Interaction.Behaviors&gt;
    &lt;/Image&gt;
    
    &lt;!-- Shows last speech command --&gt;
    &lt;TextBlock Canvas.Left=&quot;10&quot; Canvas.Top=&quot;500&quot; Text=&quot;{Binding LastCommand}&quot;
      FontSize=&quot;36&quot; Foreground=&quot;#FF001900&quot;&gt;&lt;/TextBlock&gt;
  &lt;/Canvas&gt;
  &lt;/Grid&gt;
&lt;/Window&gt;</pre>

<p>Note that both MainPage.xaml and KinectOverlay.xaml are full-screen with no Window-style but that KinectOverlay.xaml has Background=&quot;Transparent&quot; and AllowsTransparency=&quot;True&quot; attributes. This actually creates the ‘transparent overlay.’</p>

<p><font size="4">Speech recognition</font></p>

<p>If you think, after reading this, that skeleton tracking with Kinect is almost embarrassingly simple, wait till you see speech recognition. I barely scratched the surface I think, but apart from a lot of initialization bruhaha getting Kinect to recognize basic phrases is a simple matter of feeding a couple of <em>strings</em> to a “Choices” object, feeding that to a “GrammarBuilder” and finally loading that into the “SpeechRecognitionEngine” object. Add a callback to it’s SpeechRecognized property and out come your recognized strings. No calibration, initialization, no hours of ‘training’, nothing – it just works. </p>

<p>Moving back to the last part of the PoseViewModel: at the very end of it is a static property for the speech controller and a simple switch recognizing the speech commands. </p>

<pre>#region Speech commands
private static SpeechController _speechControllerInstance;
public SpeechController SpeechController
{
  get { return _speechControllerInstance ?? 
    (_speechControllerInstance = new SpeechController()); }
}

private void ProcessSpeechCommand(CommandMessage command)
{
  switch (command.Command)
  {
    case VoiceCommand.Shutdown:
      {
        Application.Current.Shutdown(); break;
      }
    //etc etc rest of the commands omitted
    case VoiceCommand.VideoOff:
      {
        ShowVideo = false; break;
      }
  }

  LastCommand = command.Command.ToString();
}
#endregion</pre>

<p>The method ProcessSpeechCommand is called whenever the model receives a CommandMessage – that is issued by the SpeechController. As you can see, the spoken commands are contained in a simple enumeration “VoiceCommand”. Being too lazy to make a proper factory for all the commands, I include the factory methods in CommandMessage as well:</p>

<pre>using System.Collections.Generic;
using Microsoft.Speech.Recognition;

namespace MapController.Messages
{
  /// &lt;summary&gt;
  /// Command the application is supposed to understand
  /// &lt;/summary&gt;
  public class CommandMessage
  {
    public VoiceCommand Command { get; set; }

    /// &lt;summary&gt;
    /// Factory methods
    /// &lt;/summary&gt;
    private static Dictionary&lt;string, VoiceCommand&gt; _commands;
    public static IDictionary&lt;string, VoiceCommand&gt; Commands
    {
      get
      {
        if (_commands == null)
        {
          _commands = new Dictionary&lt;string, VoiceCommand&gt;
          {
            {&quot;kinect engage&quot;, VoiceCommand.Engage},
            {&quot;kinect stop tracking&quot;, VoiceCommand.StopTracking},
            {&quot;kinect track&quot;, VoiceCommand.Track},
            {&quot;kinect shutdown&quot;, VoiceCommand.Shutdown},
            {&quot;kinect video off&quot;, VoiceCommand.VideoOff},
            {&quot;kinect video on&quot;, VoiceCommand.VideoOn}
          };
        }
        return _commands;
      }
    }

    public static Choices Choices
    {
      get
      {
        var choices = new Choices();
        foreach (var speechcommand in Commands.Keys)
        {
          choices.Add(speechcommand);
        }
        return choices;
      }
    }
  }
}</pre>

<p>The static Commands property is simple translation table from actual text to VoiceCommand enumeration values. The voice commands themselves (as you see, it’s just <em>strings) </em>are fed into a Choices object. Now the only thing that’s missing is the actual speech recognition ‘engine’:</p>

<pre>using System;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Threading;
using System.Windows;
using System.Windows.Threading;
using GalaSoft.MvvmLight.Messaging;
using MapController.Messages;
using Microsoft.Research.Kinect.Audio;
using Microsoft.Speech.AudioFormat;
using Microsoft.Speech.Recognition;

namespace MapController.ViewModel
{
  public class SpeechController : IDisposable
  {
    private const string RecognizerId = &quot;SR_MS_en-US_Kinect_10.0&quot;;
    private SpeechRecognitionEngine _engine;
    private KinectAudioSource _audioSource;
    private Stream _audioStream;
    private Thread _audioThread;

    public void Initialize()
    {
<font color="#ff0000">      // Audio recognition needs to happen on a separate thread
      _audioThread = new Thread(InitSpeechRecognition);
      _audioThread.Start();</font>
    }

    private void InitSpeechRecognition()
    {
      // All kinds on initialization bruhaha directly taken from sample
      _audioSource = new KinectAudioSource
                  {
                    FeatureMode = true,
                    AutomaticGainControl = false,
                    SystemMode = SystemMode.OptibeamArrayOnly
                  };
      var ri =
        SpeechRecognitionEngine.InstalledRecognizers().
          Where(r =&gt; r.Id == RecognizerId).FirstOrDefault();
      _engine = new SpeechRecognitionEngine(ri.Id);
      var gb = new GrammarBuilder { Culture = new CultureInfo(&quot;en-US&quot;) };

     <font color="#ff0000"> // Building my command list
      gb.Append(CommandMessage.Choices);</font>

      // More initialization bruhaha directly taken from sample
      var g = new Grammar(gb);
      _engine.LoadGrammar(g);
      _engine.SpeechRecognized += SreSpeechRecognized;

      _audioStream = _audioSource.Start();
      _engine.SetInputToAudioStream(_audioStream,
                                    new SpeechAudioFormatInfo(
                                    EncodingFormat.Pcm, 16000, 16, 1,
                                    32000, 2, null));
      _engine.RecognizeAsync(RecognizeMode.Multiple);
    }

<font color="#ff0000">    private void SreSpeechRecognized(object sender, 
      SpeechRecognizedEventArgs e)
    {
      // Convert spoken text into a command
      if (CommandMessage.Commands.ContainsKey(e.Result.Text))
      {
        Application.Current.Dispatcher.Invoke(DispatcherPriority.Normal,
          new Action(() =&gt;
            Messenger.Default.Send(
               new CommandMessage { 
               Command = CommandMessage.Commands[e.Result.Text] })));
      }
    }</font>
  }
}</pre>

<p>This is mostly converted from the basic Speech sample. Only the red things are actually (mostly) mine. Most interesting to note is the fact that for some reason speech recognition needs to be done <em>on a separate thread</em>. Don’t ask me why – it just needs to. In the middle you can see I feed my Choices-built-from-commands&#160; to a ‘SpeechRecognitionEngine’ going via the ‘GrammarBuilder’ as described earlier, and the SreSpeechRecognized that fires when a speech command is recognized. I call the Messenger back on the UI thread (remember, we are on a separate thread here so nothing bound can be accessed directly) and the result is fired back into the ProcessSpeechCommand of the model, that acts on it as described above.</p>

<p>Caveat: this speech recognition does not work with an ordinary microphone. Kinect is doing the recognition, apparently. Speech recognition samples without a Kinect connected to your computer simply do not start up.</p>

<p><font size="4">Conclusion and lessons learned</font></p>

<p>As said before, the solution is pretty crude, and so is the user experience. For instance, the application might start with measuring body dimensions. A person with arms shorter that 50 cm would have trouble getting the application to pan, for instance ;-).&#160; But for a first try – with no prior experience – I think it’s a nice start of getting off the ground with Kinect development. I had tremendous fun experimenting with it, although I got a bit distracted from my main passion, i.e. Windows Phone 7. I hope to show this very soon at Vicrea and who knows, maybe this will turn into actual work ;-) </p>

<p>Apart from the actual knowledge and concepts of the API and Kinect controlling, I have learned the following lessons from this application</p>

<ol>
  <li>A good technical implementation of controlling applications with gestures needs an API that is supplied <em>by the controlled application,&#160; or some kind of wrapper</em>. I now use a pretty crude trick, by simulating mouse actions. For a real gesture controlled application something more is needed </li>

  <li>When it comes to gesture control, you are basically on your own, without guidelines on ‘how to do things’. For the past 20 years we’ve been using mouse and keyboard to control our computers. This led to a well defined ‘language’ of ‘concepts that has firmly taken root in our consciousness – things like clicking left and right buttons, dragging, using the mouse wheel for zooming in our out, using cursor keys, menu structures (like about/help and tools/properties) – heck, things like CTRL-ALT-DELETE even have become a figure of speech. But when in comes to gestures, <em>there are no rules</em>, written or unwritten, that describe the ‘logical’ way of zooming and panning a map. Apart from creating the application itself, I had to ‘invent’ the actual poses or gestures. So the logic in zooming out by pulling a hand toward me is mine, but not necessarily yours. A very odd experience. But a fun one. </li>
</ol>

<p>Sample solution can be obtained <a href="http://www.schaikweb.net/dotnetbyexample/mapcontroller.zip" target="_blank">here</a>.</p>